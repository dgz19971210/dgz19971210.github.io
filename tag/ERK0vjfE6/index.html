<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="轻尘的个人博客">
<meta name="description" content="是非在己，毁誉由人，得失不论">
<meta name="theme-color" content="#000">
<title>轻尘</title>
<link rel="shortcut icon" href="/favicon.ico?v=1604981539311">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>轻尘</span>
            </a>  
          
        </div>
        
          <p class="subtitle">是非在己，毁誉由人，得失不论</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">轻尘</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>是非在己，毁誉由人，得失不论</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">15</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://dgzd.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          Git
          <small>标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://dgzd.github.io/post/git/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              07-07
              <small>Git 指令</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">轻尘</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/mq/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;消息队列简介&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是消息队列&#34;&gt;什么是消息队列&lt;/h2&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务员点菜快，厨师做菜慢，服务员只需要给厨师点菜单即可，然后就可以继续去服务谷歌，不需要等待厨师把菜做完。点菜单就相当于消息，放单子的位置就相当少队列。&lt;/li&gt;
&lt;li&gt;业务系统需要发短信，但短信发送模块速度跟不上，业务系统就可以吧发送短信的两个人信息封装为一个消息，放入队列，短信发送模块从队列中获取消息进行处理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MQ，是一种跨进程的通信机制，用于上下游传递消息。&lt;/p&gt;
&lt;p&gt;在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。&lt;/p&gt;
&lt;p&gt;使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_35152037/article/details/80012961&#34;&gt;使用场景&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;消息队列（Message Queue）是一种不同应用程序之间（跨进程）的通信方式。应用程序通过写入和检索出入列队的数据（消息）来通信，而无需通过专用链接来连接它们。&lt;/p&gt;
&lt;p&gt;消息发送后可以立即返回，由消息系统来确保信息的可靠传递，消息发布者只管把消息发布到 MQ 中而不管谁来取，消息使用者只管从 MQ 中区消息而不管谁发布的，发布者和使用者都不知道对方的存在&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接调用通常是用于诸如 &lt;strong&gt;远程过程调用&lt;/strong&gt; (Remote Procedure Call. RPC)的技术。&lt;/p&gt;
&lt;p&gt;排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求，这样天然的就实现了异步的目标。&lt;/p&gt;
&lt;h2 id=&#34;为什么要使用消息队列&#34;&gt;为什么要使用消息队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;解耦、异步、削峰&lt;/li&gt;
&lt;li&gt;参考：&lt;a href=&#34;https://blog.csdn.net/weixin_40753536/article/details/82383304&#34;&gt;为什么要使用 MQ&lt;/a&gt;、&lt;a href=&#34;https://blog.csdn.net/qq_34288630/article/details/79411529&#34;&gt;什么是消息队列&lt;/a&gt;、&lt;a href=&#34;https://www.liangzl.com/get-article-detail-1992.html&#34;&gt;消息队列的功能场景 - 京东技术&lt;/a&gt; 、&lt;a href=&#34;https://blog.csdn.net/alinshen/article/details/80583214&#34;&gt;消息队列会遇到的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解耦&#34;&gt;解耦&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传统模式的缺点&lt;/strong&gt;：系统间耦合性太强，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间件模式的优点&lt;/strong&gt;：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而实现解耦。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g1om5zqkf1j30hi06xmy0.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：订单系统生成订单，推送到 MQ 后立即返回，结算系统从 MQ 拉取订单并处理&lt;/p&gt;
&lt;p&gt;MQ最直接的使用场景就是可以将两个系统进行解耦，比如我们的货款抵扣业务场景，用户生成订单发送MQ后立即返回，结算系统去消费该MQ进行用户账户金额的扣款。这样订单系统只需要关注把订单创建成功，最大可能的提高订单量，并且生成订单后立即返回用户。而结算系统重点关心的是账户金额的扣减，保证账户金额最终一致。这个场景里面还会涉及到重试幂等性问题&lt;/p&gt;
&lt;h3 id=&#34;异步&#34;&gt;异步&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传统模式&lt;/strong&gt;：一些非必要的业务逻辑以同步的方式运行，太耗费时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间件模式&lt;/strong&gt;：将消息写入消息队列，使非必要的业务逻辑以异步的方式运行，加快响应速度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：订单系统&lt;/p&gt;
&lt;p&gt;用户点击 【下单】按钮后的业务逻辑包括：扣减库存、生成相应的订单数据、下单、发送消息通知等&lt;/p&gt;
&lt;p&gt;在业务发展的初期，这些逻辑可能放在一起同步执行，但随着业务的整张，，需要提升系统服务的性能，这时候可以将一些不需要立即生效的操作拆分出来异步执行，比如发送消息等。这种场景就可以使用 MQ，在下单的主流程(比如扣减库存、生成相应的单据) 完成之后，发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取 MQ 的消息 ( 或者让 MQ 推送消息 )&lt;/p&gt;
&lt;p&gt;上述订单系统中，把下单后发送消息通知存放到 MQ ，通过另外的线程单独调用，就是异步的体现&lt;/p&gt;
&lt;h3 id=&#34;削峰&#34;&gt;削峰&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;传统模式&lt;/strong&gt;：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间件模式&lt;/strong&gt;：把要处理的请求放入MQ，系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：平衡高并发时期的流量&lt;/p&gt;
&lt;p&gt;还是以订单系统和结算系统场景为例，如果订单系统通过RPC框架来调用结算系统，在有高峰促销的情况下生成订单的量会非常大，而且由于生成订单的速度也非常快，这样势必会给结算系统造成系统压力，服务器利用率则会偏高，但在不是高峰的时间点订单量比较小，结算系统的服务器利用率则会偏低。&lt;/p&gt;
&lt;h2 id=&#34;消息队列的优缺点&#34;&gt;消息队列的优缺点&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/qq_34288630/article/details/79411529&#34;&gt;什么是消息队列&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么要分布式消息队列&#34;&gt;为什么要分布式消息队列&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;多系统协作需要分布式&lt;/p&gt;
&lt;p&gt;例如消息队列的数据需要在多个系统之间共享，所以需要提供分布式通信机制，协同机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可靠&lt;/p&gt;
&lt;p&gt;消息会被持久化到分布式存储中，这样避免了单台机器存储的消息由于机器问题导致的消息丢失&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展&lt;/p&gt;
&lt;p&gt;分布式消息队列，会随着访问量的增加而方便的增加处理服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提高系统响应速度&lt;/p&gt;
&lt;p&gt;使用消息队列，生产者一方把消息往消息队列里一扔，就可以立马返回响应用户，无需等待处理结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证消息的传递&lt;/p&gt;
&lt;p&gt;如果发送消息时接收者不可用，消息队列就会保留消息，直到成功的传递它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解耦&lt;/p&gt;
&lt;p&gt;只要信息格式不变，即使接收者的接口、位置、或者配置改变，也不会给发送者带来任何改变&lt;br&gt;
消息发送者无需知道消息接收者是谁，使得系统设计更清晰&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;系统可用性降低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统复杂性增加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。&lt;/p&gt;
&lt;p&gt;但是，我们该用还是要用的。&lt;/p&gt;
&lt;h2 id=&#34;常见问题&#34;&gt;常见问题&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/alinshen/article/details/80583214&#34;&gt;消息队列会遇到的问题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何保证消息队列是高可用&#34;&gt;如何保证消息队列是高可用&lt;/h3&gt;
&lt;p&gt;分析：引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。&lt;br&gt;
回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。&lt;br&gt;
以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。&lt;/p&gt;
&lt;p&gt;至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。&lt;br&gt;
要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。&lt;/p&gt;
&lt;h3 id=&#34;如何保证消息不被重复消费&#34;&gt;如何保证消息不被重复消费&lt;/h3&gt;
&lt;p&gt;这个问题其实换一种问法就是 —— 如何保证消息队列的幂等性?&lt;/p&gt;
&lt;p&gt;这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。&lt;/p&gt;
&lt;p&gt;先来说一下为什么会造成重复消费?&lt;/p&gt;
&lt;p&gt;其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因，就是&lt;strong&gt;因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何解决?这个问题针对业务场景来答分以下几点&lt;/p&gt;
&lt;p&gt;1. 比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。&lt;br&gt;
  2. 再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。&lt;br&gt;
  3. 如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;/p&gt;
&lt;h3 id=&#34;如何保证消费的可靠性传输&#34;&gt;如何保证消费的可靠性传输&lt;/h3&gt;
&lt;p&gt;其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生产者弄丢数据&lt;/p&gt;
&lt;p&gt;从生产者弄丢数据来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢失消息&lt;/p&gt;
&lt;p&gt;transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。&lt;/p&gt;
&lt;p&gt;然而缺点就是吞吐量下降了。生产上用confirm模式的居多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列弄丢数据&lt;/p&gt;
&lt;p&gt;针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。&lt;/p&gt;
&lt;p&gt;开启持久化磁盘的配置。这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 ACK 信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者弄丢数据&lt;/p&gt;
&lt;p&gt;消费者丢失数据一般是因为采用了自动确认消息模式。这种模式下消费者会自动确认收到消息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;如何保证消息的顺序性&#34;&gt;如何保证消息的顺序性&lt;/h3&gt;
&lt;p&gt;通过某种算法，&lt;strong&gt;将需要保持先后顺序的消息放到同一个消息队列中&lt;/strong&gt; (kafka中就是partition,rabbitMq中就是queue)。&lt;strong&gt;然后只用一个消费者去消费该队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？&lt;/p&gt;
&lt;p&gt;这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。&lt;br&gt;
总之，针对这个问题，我的观点是&lt;strong&gt;保证入队有序就行，出队以后的顺序交给消费者自己去保证&lt;/strong&gt;，没有固定套路。&lt;/p&gt;
&lt;h2 id=&#34;消息队列选型&#34;&gt;消息队列选型&lt;/h2&gt;
">消息队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/docker-gai-shu/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;关于 Docker、Dockerfile、docker-compose 简单概述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Docker 是一种容器技术，作用是用来快速部署服务&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker-解决了什么问题&#34;&gt;Docker 解决了什么问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Docker解决了运行环境和配置问题，方便发布，也就方便做持续集成&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更轻量的虚拟化，节省了虚拟机的性能损耗&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker-应用场景&#34;&gt;Docker 应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序分发，gitlab的安装很恶心吧，所以有人做了gitlab的image&lt;/li&gt;
&lt;li&gt;部署发布，可以很好的解决环境和配置问题&lt;/li&gt;
&lt;li&gt;PaaS，tsuru、flynn都是基于Docker的，CloudFoundry也要从warden迁移到Docker，不解释&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;容器的启动过程&#34;&gt;容器的启动过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;docker client(即：docker终端命令行)会调用docker daemon请求启动一个容器，&lt;/li&gt;
&lt;li&gt;docker daemon会向host os(即：linux)请求创建容器&lt;/li&gt;
&lt;li&gt;linux会创建一个空的容器（可以简单理解为：一个未安装操作系统的裸机，只有虚拟出来的CPU、内存等硬件资源）&lt;/li&gt;
&lt;li&gt;docker daemon请检查本机是否存在docker镜像文件（可以简单理解为操作系统安装光盘），如果有，则加载到容器中（即：光盘插入裸机，准备安装操作系统）&lt;/li&gt;
&lt;li&gt;将镜像文件加载到容器中（即：裸机上安装好了操作系统，不再是裸机状态）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;docker-安装和基础命令&#34;&gt;Docker 安装和基础命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;请阅读：&lt;a href=&#34;https://ding.gq/Ubuntu%E5%AE%89%E8%A3%85Docker.html#more&#34;&gt;Ubuntu 安装及使用 Docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h1&gt;
&lt;h2 id=&#34;简介-2&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此没一条指令的内容，就是描述该层应当如何构建&lt;/p&gt;
&lt;h2 id=&#34;命令详解&#34;&gt;命令详解&lt;/h2&gt;
&lt;h3 id=&#34;from&#34;&gt;FROM&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指定基础镜像&lt;/strong&gt;。必备指令，必须是 Dockerfile 文件的第一条指令&lt;/p&gt;
&lt;h3 id=&#34;run&#34;&gt;RUN&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;执行命令&lt;/strong&gt;。命令有两种书写格式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;shell 格式：&lt;code&gt;RUN&lt;/code&gt; 后直接书写命令，就像在 shell 中一样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exec 格式：&lt;code&gt;RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;RUN [&amp;quot;chmod&amp;quot;,&amp;quot;+x&amp;quot;,&amp;quot;start.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;copy&#34;&gt;COPY&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;复制文件&lt;/strong&gt;。把文件从本机 &lt;code&gt;上下文目录中&lt;/code&gt; 复制到容器中，和 &lt;code&gt;RUN&lt;/code&gt;指令 一样有两种格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# 格式1
COPY package.json /usr/src/app/

# 格式2
COPY [&amp;quot;package.json&amp;quot;,&amp;quot;/usr/src/app/&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;add&#34;&gt;ADD&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更高级的复制命令&lt;/strong&gt;。和 &lt;code&gt;COPY&lt;/code&gt; 的使用格式一致，但在其基础上加了一些功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源路径可以是 URL，Docker 引擎会去下载链接文件放到目标路径，并设置权限为 &lt;code&gt;600&lt;/code&gt; ，不如直接使用 &lt;code&gt;RUN&lt;/code&gt; 指令配合 &lt;code&gt;wget&lt;/code&gt; 或 &lt;code&gt;curl&lt;/code&gt;，所以&lt;strong&gt;不推荐使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 为一个 &lt;code&gt;tar&lt;/code&gt; 压缩文件的话，压缩格式为 &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的情况下，&lt;code&gt;ADD&lt;/code&gt; 指令将会自动解压缩这个压缩文件到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cmd&#34;&gt;CMD&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;容器启动时运行命令&lt;/strong&gt;。命令格式和 &lt;code&gt;RUN&lt;/code&gt; 相似，在容器启动是会执行 CMD 所指定的命令&lt;/p&gt;
&lt;h3 id=&#34;entrypoint&#34;&gt;ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指定容器启动时要运行的命令&lt;/strong&gt;。目的和 &lt;code&gt;CMD&lt;/code&gt; 一样，格式也是 &lt;code&gt;RUN&lt;/code&gt; 指令的格式&lt;/p&gt;
&lt;p&gt;但当指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的含义就发生了改变，不再是直接的运行其命令，而是将 &lt;code&gt;CMD&lt;/code&gt; 的内容作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令，换句话说实际执行时，将变为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;&amp;lt;ENTRYPOINT&amp;gt; &amp;quot;&amp;lt;CMD&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;env&#34;&gt;ENV&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置环境变量&lt;/strong&gt;。在 Dockerfile 文件中设置环境变量，让下面的内容可以引用&lt;/p&gt;
&lt;p&gt;无论是后面的其它指令，如 &lt;code&gt;RUN&lt;/code&gt;，还是运行时的应用，都可以直接使用这里定义的环境变量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;ENV NODE_VERSION 7.2.0

# 可多次引用上面所定义的环境变量
RUN curl -SLO &amp;quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arg&#34;&gt;ARG&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;构建参数&lt;/strong&gt;。效果和 &lt;code&gt;ENV&lt;/code&gt; 一样，都是设置环境变量&lt;/p&gt;
&lt;p&gt;所不同的是，&lt;code&gt;ARG&lt;/code&gt; 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 &lt;code&gt;ARG&lt;/code&gt; 保存密码之类的信息，因为 &lt;code&gt;docker history&lt;/code&gt; 还是可以看到所有值的。&lt;/p&gt;
&lt;h3 id=&#34;volume&#34;&gt;VOLUME&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义匿名卷&lt;/strong&gt;。把容器中的目录挂载出来作为匿名卷，当向容器中写入数据时，不会写入容器中，会写入在本地的卷中&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# 把某一个目录挂载为匿名卷
VOLUME &amp;lt;路径&amp;gt;

#挂载多个目录为匿名卷
VOLUME [&amp;quot;&amp;lt;路径1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;路径2&amp;gt;&amp;quot;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;VOLUME /data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;/data&lt;/code&gt; 目录就会在运行时自动挂载为匿名卷，任何向 &lt;code&gt;/data&lt;/code&gt; 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run -d -v mydata:/data xxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这行命令中，就使用了 &lt;code&gt;mydata&lt;/code&gt; 这个命名卷挂载到了 &lt;code&gt;/data&lt;/code&gt; 这个位置，替代了 &lt;code&gt;Dockerfile&lt;/code&gt; 中定义的匿名卷的挂载配置。&lt;/p&gt;
&lt;h3 id=&#34;expose&#34;&gt;EXPOSE&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;暴露端口&lt;/strong&gt;。声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务&lt;/p&gt;
&lt;p&gt;在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 &lt;code&gt;docker run -P&lt;/code&gt;时，会自动随机映射 &lt;code&gt;EXPOSE&lt;/code&gt; 的端口。&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;workdir&#34;&gt;WORKDIR&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指定工作目录&lt;/strong&gt;。指定工作目录（或者称为当前目录）以后，各层的当前目录就被改为指定的目录，如该目录不存在，&lt;code&gt;WORKDIR&lt;/code&gt; 会帮你建立目录。&lt;/p&gt;
&lt;h3 id=&#34;user&#34;&gt;USER&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指定当前用户&lt;/strong&gt;。和 &lt;code&gt;WORKDIR&lt;/code&gt; 相似，都是改变环境状态并影响以后的层。&lt;code&gt;WORKDIR&lt;/code&gt; 是改变工作目录，&lt;code&gt;USER&lt;/code&gt;则是改变之后层的执行 &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; 以及 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 这类命令的身份。&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;USER &amp;lt;用户名&amp;gt;[:&amp;lt;用户组&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;healthcheck&#34;&gt;HEALTHCHECK&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;HEALTHCHECK [选项] CMD &amp;lt;命令&amp;gt; # 设置检查容器健康状况的命令

HEALTHCHECK NONE    # 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;onbuild&#34;&gt;ONBUILD&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为他人做嫁衣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ONBUILD&lt;/code&gt; 是一个特殊的指令，它后面跟的是其它指令，比如 &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt; 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。&lt;/p&gt;
&lt;h1 id=&#34;docker-compose&#34;&gt;Docker Compose&lt;/h1&gt;
&lt;h2 id=&#34;简介-3&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Docker Compose 是用来对 docker 容器编排，把所有繁复的 docker 操作全都一条命令，自动化的完成。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;p&gt;在 Linux 上安装十分简单。从 &lt;a href=&#34;https://github.com/docker/compose/releases&#34;&gt;官方 GitHub Release&lt;/a&gt; 处直接下载编译好的二进制文件即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -L https://github.com/docker/compose/releases/download/1.24.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;卸载&#34;&gt;卸载&lt;/h2&gt;
&lt;p&gt;如果是二进制包安装的，删除二进制包即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo rm /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;compose-模板文件&#34;&gt;Compose 模板文件&lt;/h2&gt;
&lt;p&gt;MySQL + Nginx + Tomcat 的商城项目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;3&#39;
services:
  tomcat:
    restart: always
    build:
      context: ./bookstore_admin
      dockerfile: tomcat_dockerfile
    image: tomcat
    container_name: tomcat
    ports:
      - 8080:8080
    networks:
      - my_net
    environment:
      TZ: Asia/Shanghai

  nginx:
    restart: always
    image: nginx
    container_name: nginx
    ports:
      - 80:80
    networks:
       - my_net
    volumes:
      - ./conf/nginx.conf:/etc/nginx/nginx.conf
      - ./wwwroot:/usr/share/nginx/wwwroot

  db:
    restart: always
    build:
      context: ./bookstore_db
      dockerfile: Dockerfile
    container_name: mysql
    ports:
      - 3306:3306
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: root
    command:
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
      --explicit_defaults_for_timestamp=true
      --lower_case_table_names=1
      --max_allowed_packet=128M
      --sql-mode=&amp;quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&amp;quot;
    volumes:
      - ./data/mysql:/var/lib/mysql
    networks:
      - my_net

networks:
  my_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.1/16

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;docker-compose常用命令&#34;&gt;Docker Compose常用命令&lt;/h2&gt;
&lt;h3 id=&#34;build&#34;&gt;build&lt;/h3&gt;
&lt;p&gt;构建（重新构建）项目中的服务容器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker-compose build -f yml文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;up&#34;&gt;up&lt;/h3&gt;
&lt;p&gt;构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker-compose -f yml文件 up 

# -d 以守护进程运行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;down&#34;&gt;down&lt;/h3&gt;
&lt;p&gt;停止up 命令启动的容器并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker-compose -f xx.yml down
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;logs&#34;&gt;logs&lt;/h3&gt;
&lt;p&gt;查看服务容器的输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker-compose logs [options] [SERVICE...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;rm&#34;&gt;rm&lt;/h3&gt;
&lt;p&gt;删除所有（停止状态的）服务容器。推荐先执行 &lt;code&gt;docker-compose stop&lt;/code&gt; 命令来停止容器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker-compose rm [options] [SERVICE...]

# -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
# -v  删除容器所挂载的数据卷
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他命令&#34;&gt;其他命令&lt;/h3&gt;
&lt;p&gt;请查看 &lt;a href=&#34;https://yeasy.gitbooks.io/docker_practice/compose/commands.html&#34;&gt;Docker从入门到实战&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;docker-网络设置&#34;&gt;Docker 网络设置&lt;/h1&gt;
&lt;h2 id=&#34;查看-docker-的网卡&#34;&gt;查看 docker 的网卡&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;$ docker network ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker安装后，默认会创建下面三种网络类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bridge：桥接网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下启动的 Docker 容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker 的 IP 地址就变了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;host：主机网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;--network=host&lt;/code&gt; ，此时，Docker 容器的网络会附属在主机上，两者是互通的。&lt;br&gt;
例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;none：无指定网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;--network=none&lt;/code&gt; ，docker 容器就不会分配局域网的IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;启动-docker时指定网络类型&#34;&gt;启动 Docker时指定网络类型&lt;/h2&gt;
&lt;p&gt;在 docker 容器启动时，把容器加入指定的网络，使用 &lt;code&gt;--network 网络类型&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run -itd --name test1 --network bridge --ip 172.17.0.10 centos:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建自定义网络为容器设置固定ip&#34;&gt;创建自定义网络：（为容器设置固定IP）&lt;/h2&gt;
&lt;p&gt;启动 Docker 容器的时候，使用默认的网络是不支持指派固定IP的，如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run -itd --net bridge --ip 172.17.0.10 centos:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会出现错误提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker: Error response from daemon: User specified IP address is supported on user defined networks only.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式如下&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建自定义网络&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker network create --subnet=172.18.0.0/16 mynetwork
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 Docker 容器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;docker run -itd --name networkTest1 --net mynetwork --ip 172.18.0.2 centos:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：当使用 docker-conpose 文件时，可以在 compose 文件中设置容器的网络&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/neptunemoon/p/6512121.html#toc_2&#34;&gt;neptune 破壁人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/xuezhigu/p/8257129.html&#34;&gt;雪之谷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yeasy.gitbooks.io/docker_practice/image/build.html&#34;&gt;Docker从入门到实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">Docker 概述</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/tcp-de-san-ci-wo-shou-he-si-ci-hui-shou/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简述TCP的三次握手和四次挥手。一些个人的简单理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;tcp-的六种标志位&#34;&gt;TCP 的六种标志位&lt;/h2&gt;
&lt;h3 id=&#34;syn-同步标志&#34;&gt;SYN 同步标志&lt;/h3&gt;
&lt;p&gt;同步序列编号（&lt;strong&gt;Synchronize Sequence Numbers&lt;/strong&gt;）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。&lt;/p&gt;
&lt;h3 id=&#34;ack确认标志&#34;&gt;ACK：确认标志&lt;/h3&gt;
&lt;p&gt;确认编号（&lt;strong&gt;Acknowledgement Number&lt;/strong&gt;）在数据通信中，接收站发给发送站的一种传输类&lt;a href=&#34;https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704&#34;&gt;控制字符&lt;/a&gt;。表示发来的数据已确认接收无误。&lt;/p&gt;
&lt;h3 id=&#34;psh-推标志&#34;&gt;PSH 推标志&lt;/h3&gt;
&lt;p&gt;该标志置位时，接收端不将该&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE&#34;&gt;数据&lt;/a&gt;进行队列处理，而是尽可能快将数据转由应用处理。在处理 &lt;a href=&#34;https://baike.baidu.com/item/telnet&#34;&gt;telnet&lt;/a&gt; 或 rlogin 等交互模式的连接时，该标志总是置位的。&lt;/p&gt;
&lt;h3 id=&#34;fin-结束标志&#34;&gt;FIN 结束标志&lt;/h3&gt;
&lt;p&gt;带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。&lt;/p&gt;
&lt;h3 id=&#34;urg-紧急标志&#34;&gt;URG 紧急标志&lt;/h3&gt;
&lt;p&gt;指镇优先（&lt;strong&gt;Urgent Pointer&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&#34;rst-复位标志&#34;&gt;RST 复位标志&lt;/h3&gt;
&lt;p&gt;用于复位相应的TCP连接。&lt;/p&gt;
&lt;h2 id=&#34;tcp-三次握手&#34;&gt;TCP 三次握手&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukssf46mj30ed08gwei.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;SYN ( Synchronize Sequence Numbers )：同步序列号，用于建立连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ACK ( Acknowledgement )：确认序列号有效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;seq ( Sequence number )： 顺序号码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ack ( Acknowledge number )：确认号码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。&lt;/li&gt;
&lt;li&gt;第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/li&gt;
&lt;li&gt;第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么要三次握手&#34;&gt;为什么要三次握手&lt;/h2&gt;
&lt;p&gt;在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。&lt;/p&gt;
&lt;p&gt;问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。&lt;/p&gt;
&lt;p&gt;我们再来考虑，如果不是三次握手会出现什么情况呢：&lt;/p&gt;
&lt;p&gt;假设有A和B两端要进行通信，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是只有一次握手的话，这样肯定是不行的，A压根都不知道B是不是收到了这个请求。TCP协议变的与面向无连接的UDP 协议无异&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。也可能 B 收到的是 A 发送的失效了的报文（A发送后，由于某种原因没收到回应，报文被作废），B 建立了连接，A 却一直没有发送数据，占用着 B 的连接资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tcp-四次挥手&#34;&gt;TCP 四次挥手&lt;/h2&gt;
&lt;p&gt;所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukuxutooj30e308zjrf.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。&lt;/li&gt;
&lt;li&gt;第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。&lt;/li&gt;
&lt;li&gt;第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。&lt;/li&gt;
&lt;li&gt;第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;被动关闭具体流程：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0unpy9lz2j30dz05b0sp.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;为什么要四次挥手&#34;&gt;为什么要四次挥手&lt;/h2&gt;
&lt;p&gt;本质的原因是tcp是全双工的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。&lt;/p&gt;
&lt;p&gt;因为TCP有个半关闭状态，假设A.B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。&lt;/p&gt;
&lt;p&gt;在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是&lt;strong&gt;全双工模式&lt;/strong&gt;，&lt;strong&gt;接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手牵扯到的状态装换：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；&lt;/p&gt;
&lt;p&gt;**FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；&lt;/p&gt;
&lt;p&gt;**TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；&lt;/p&gt;
&lt;p&gt;**CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；&lt;/p&gt;
&lt;p&gt;**CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；&lt;/p&gt;
&lt;p&gt;**LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；&lt;/p&gt;
&lt;p&gt;**CLOSED ** 这个状态表示连接已经断开。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0uowyfpy6j30k00mbq3x.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_34386891/article/details/80515912&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/e7f45779008a&#34;&gt;简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sdgihshdv/article/details/79503274&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/zzhongcy/article/details/38851271&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">TCP的三次握手和四次挥手</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/ubuntu-docker/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 下安装及使用 Docker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;p&gt;Docker 是将发布程序运行所需要的环境打包到一起，自动化运行的容器；是一个开源项目，支持大部分的 Linux 发行版，操作系统层以上的虚拟化技术。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;p&gt;与传统的虚拟化方式相比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更高效的利用系统资源&lt;/li&gt;
&lt;li&gt;更快的启动速度&lt;/li&gt;
&lt;li&gt;一致的运行环境&lt;/li&gt;
&lt;li&gt;持续交互和部署&lt;/li&gt;
&lt;li&gt;更轻松的迁移&lt;/li&gt;
&lt;li&gt;更轻松的维护和扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组成&#34;&gt;组成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker Client：通过 Api 访问 Docker Daemon 管理 Docker 镜像&lt;/li&gt;
&lt;li&gt;Docker Daemon：守护进程，负责 Docker 镜像的创建、删除、启动、停止等服务&lt;/li&gt;
&lt;li&gt;Docker Image：镜像，一张 “只读” 的系统 CD&lt;/li&gt;
&lt;li&gt;Docker Container：Docker 的容器，Docker Images 运行实例&lt;/li&gt;
&lt;li&gt;Docker Registry：Docker Images 的仓库，Docker Hub：https://www.dockerhub.com&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ubuntu-安装-docker&#34;&gt;Ubuntu 安装 Docker&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://www.jianshu.com/p/07e405c01880&#34;&gt;简书&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;方式一&#34;&gt;方式一&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用官方脚本自动安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方式二&#34;&gt;方式二&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;添加HTTPS协议，允许apt从HTTPS安装软件包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get install  apt-transport-https  ca-certificates curl  software-properties-common

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 Docker 公共密钥&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# docker 官方源
curl -fsSL  https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add

# docker 中科大源，添加中科大即可
curl -fsSL  https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置版本库类型（Ubuntu18.04对应版本**“bionic“”**），软件版本包括三种：stable、edge、test&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Docker 官方
sudo add-apt-repository &amp;quot;deb [arch=amd64]  https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;quot; 


# Docker 中科大
sudo add-apt-repository &amp;quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot; 

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 Docker CE&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 更新 apt-get 源
sudo apt-get update

# 安装
sudo apt-get install docker-ce
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;docker-常用命令&#34;&gt;Docker 常用命令&lt;/h2&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://blog.csdn.net/hcljava/article/details/78588623&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;添加用户到-docker-用户组&#34;&gt;添加用户到 docker 用户组&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 docker 用户组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo groupadd docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把需要的用户加入 docker 用户组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo usermod -aG docker ${USER}

sudo gpasswd -a dylan docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 docker 服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo systemctl restart docker

sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换用户后重新登录此普通用户，才能生效&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;docker-基本&#34;&gt;Docker 基本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动 docker&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl start docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 docker 版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 简单查看版本
docker -v  [--version]

# 查看详细版本
docker version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示 docker 系统的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker info
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操纵-docker-镜像&#34;&gt;操纵 Docker 镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检索 image&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker search image-name
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载 image&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull image-name
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出镜像列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除一个或多个 images 镜像（删除时需要先删除容器，使用 &lt;code&gt;docker ps -a&lt;/code&gt; 查看运行的容器，使用 &lt;code&gt;docker rm 容器id&lt;/code&gt; 删除容器） ——参考：&lt;a href=&#34;https://blog.csdn.net/flydreamzhll/article/details/80900509&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rmi image-name
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示一个镜像的历史&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker history image-name
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过容器创建镜像&lt;/p&gt;
&lt;p&gt;从已经创建的容器中更新镜像，并且提交这个镜像 *使用 Dockerfile 指令来创建一个新的镜像 下面通过已存在的容器创建一个新的镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit -m=&amp;quot;First Image&amp;quot; -a=&amp;quot;keke&amp;quot; 7a15f99695c0 keke/unbantu:17.10.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-m  提交的描述信息
-a  指定镜像作者
7a15f99695c0 记住这个是容器id，不是镜像id
keke/unbantu:17.10.0 创建的目标镜像名
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;镜像发布&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; 注册账户，发布的镜像都在&lt;a href=&#34;https://cloud.docker.com/repository/list&#34;&gt;这个页面里&lt;/a&gt;展示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上面做的镜像unbantu，起个新的名字unbantu-test&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker tag keke/unbantu:17.10.0 keke/unbantu-test:lastest
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录 docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker login
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传 Ubuntu 镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker push keke/unbantu-test:lastest
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;启动容器&#34;&gt;启动容器&lt;/h3&gt;
&lt;p&gt;Docker 容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在容器中安装新的程序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run image-name apt-get install -y -name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在容器中运行库 echo 命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run image-name echo &amp;quot;hello word&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交互式进入容器中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -i -t image_name /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查看容器&#34;&gt;查看容器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列出当前所有正在运行的 container&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出所有的 container&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出最近一次启动的 container&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker ps -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操纵容器&#34;&gt;操纵容器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保存对容器的修改&lt;/p&gt;
&lt;p&gt;当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit ID new-image-name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项：&lt;code&gt;-a, --author=&amp;quot;&amp;quot; Author; -m, --message=&amp;quot;&amp;quot; Commit message&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rm `docker ps -a -q`
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除单个容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker rm Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止、启动、杀死一个容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker stop Name/ID  

docker start Name/ID  

docker kill Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从一个容器中取出日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker logs Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-f, --follow=false Follow log output; -t, --timestamps=false Show timestamps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker diff Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示一个运行的容器里面的进程信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker top Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从容器里面拷贝文件/目录到本地一个路径&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker cp Name:/container-path to-path  

docker cp ID:/container-path to-path
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.重启一个正在运行的容器&lt;/p&gt;
&lt;p&gt;-t, --time=10 Number of seconds to try to stop for before killing the container, Default=10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker restart Name/ID
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在容器外，使用容器执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec 容器名 命令

docker exec -i -t  mynginx /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;附加到一个运行的容器上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker attach ID #重新启动并运行一个交互式会话shell
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构建镜像&#34;&gt;构建镜像&lt;/h3&gt;
&lt;h4 id=&#34;一-通过-commit-命令提交容器为镜像&#34;&gt;一、通过 commit 命令提交容器为镜像&lt;/h4&gt;
&lt;p&gt;在容器中设置好我们所需要的配置，使用 &lt;code&gt;docker commit&lt;/code&gt; 来提交容器作为镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker commit -m=&amp;quot;A new custom image&amp;quot; --author=&amp;quot;Bourbon Tian&amp;quot; b437ffe4d630 test/apache2:webserver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; ：用来指定创建镜像要提交的消息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--author&lt;/code&gt; ：用来列出该镜像的作者信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二-通过-dockerfile-文件构建镜像&#34;&gt;二、通过 Dockerfile 文件构建镜像&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建文件夹并在其中创建 Dockerfile 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Dockerfile 中写入镜像 有关指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;docker build&lt;/code&gt; 构建镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t dylan/ubuntu:v1 . 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项：&lt;code&gt;-t&lt;/code&gt; ：tag 、&lt;code&gt;-f&lt;/code&gt;：dockerfile 文件位置&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;保存和加载镜像&#34;&gt;保存和加载镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保存镜像到一个 tar 包； -o --output=&amp;quot;&amp;quot; Write to an file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker save image-name -o file-path

# Ubuntu 上保存nginx 到 tmp 下
docker save nginx:latest &amp;gt; /tmp/nginx.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载一个tar包格式的镜像; -i, --input=&amp;quot;&amp;quot; Read from a tar archive file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker load -i file-path
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 A 机器拷贝到 B 机器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker load &amp;lt; /home/keke/main.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Ubuntu安装及使用Docker</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/ubuntu-mysql/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu安装MySql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;ubuntu-安装-mysql&#34;&gt;Ubuntu 安装 MySQL&lt;/h1&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改 apt 源（已修改的可忽略）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;备份原文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑源列表文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo vim /etc/apt/sources.list
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除原来的文件内容，添加下列源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-list&#34;&gt;deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 apt-get 数据源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 apt-get 安装 &lt;code&gt;mysql-server&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运行安全脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 MySQL 状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl status mysql.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 MySQL 版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysqladmin -p -u root version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置远程访问&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 修改配置文件
vim /etc/mysql/mysql.conf.d/mysqld.cnf

# 注释掉绑定的 IP地址
bind-address = 127.0.0.1

# 重启 MySQL
service mysql restart

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录 MySQL，并在其中操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;-- 登录
mysql -u root -p

-- 设置密码安全策略
set global validate_password_policy=0;
-- 设置密码最少长度
set global validate_password_length=1;

-- 允许root用户/密码“123456”,在localhost发起的访问
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;
-- 允许root用户/密码“123456”,在127.0.0.1发起的访问
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;
-- 允许root用户/密码“123456”,在局域网所以ip发起的访问
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;

-- 刷新权限
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;mysqld.cnf&lt;/code&gt; 配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 进入文件
vi /etc/mysql/mysql.conf.d/mysqld.cnf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;[mysqld]&lt;/code&gt; 节点上增加一个节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[client]
default-character-set=utf8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;[mysqld]&lt;/code&gt; 节点底部增加如下配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;skip-grant-tables
default-storage-engine=INNODB
character-set-server=utf8
collation-server=utf8_general_ci
lower-case-table-names = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	注：出现拒绝访问root用户的解决方案，添加上述 &lt;code&gt;skip-grant-tables&lt;/code&gt; 配置&lt;/p&gt;
&lt;p&gt;​      参考：&lt;a href=&#34;https://blog.csdn.net/qq_36675754/article/details/81381341&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​      配置文件详情：&lt;a href=&#34;https://blog.csdn.net/lienfeng6/article/details/78140404&#34;&gt;mysql配置文件详情&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 启动方式1 
service mysql start

# 启动方式2
systemctl start mysql.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;停止&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;service mysql stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;service mysql restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 MySQL 状态&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl status mysql.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;部署应用到生产环境&#34;&gt;部署应用到生产环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;导入数据库&lt;/p&gt;
&lt;p&gt;使用 MySQL 工具导入即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 Tomcat 远程访问密码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;1. 修改 Tomcat 下的 conf/tomcat-users.xml
&amp;lt;tomcat-users&amp;gt; 
&amp;lt;role rolename=&amp;quot;manager-gui&amp;quot;/&amp;gt; 
&amp;lt;role rolename=&amp;quot;admin-gui&amp;quot;/&amp;gt; 
&amp;lt;role rolename=&amp;quot;manager-script&amp;quot;/&amp;gt; 
&amp;lt;user username=&amp;quot;admin&amp;quot; password=&amp;quot;admin&amp;quot; roles=&amp;quot;manager-gui,admin-gui,manager-script&amp;quot;/&amp;gt; 
&amp;lt;/tomcat-users&amp;gt; 

2. 同时还需要修改，如无新建conf/Catalina/localhost/manager.xml 内容如下：

&amp;lt;Context privileged=&amp;quot;true&amp;quot; antiResourceLocking=&amp;quot;false&amp;quot;
         docBase=&amp;quot;${catalina.home}/webapps/manager&amp;quot;&amp;gt;
    &amp;lt;Valve className=&amp;quot;org.apache.catalina.valves.RemoteAddrValve&amp;quot; allow=&amp;quot;^.*$&amp;quot; /&amp;gt;
&amp;lt;/Context&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署 WEB 项目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手动发布&lt;/p&gt;
&lt;p&gt;访问地址：&lt;code&gt;http://10.3.133.33:8080/manager&lt;/code&gt; 页面，利用 Tomcat 进行发布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Maven 插件发布&lt;/p&gt;
&lt;p&gt;在项目最顶层添加插件，运行插件即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- tomcat插件 --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;url&amp;gt;http://10.3.50.119:8080/manager/text&amp;lt;/url&amp;gt;
                    &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
                    &amp;lt;password&amp;gt;admin&amp;lt;/password&amp;gt;
                    &amp;lt;update&amp;gt;true&amp;lt;/update&amp;gt;
                    &amp;lt;path&amp;gt;/test&amp;lt;/path&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Ubuntu安装MySql</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/ubuntu-tomcat/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 安装 Tomcat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;ubuntu-安装-tomct&#34;&gt;Ubuntu 安装 Tomct&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;官网下载 Linux 对应的安装包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tomcat.apache.org/download-80.cgi&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上传并解压缩，移动到 &lt;code&gt;/usr/local/tomcat8&lt;/code&gt;，设置所有者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 解压
tar -zxvf apache-tomcat-8.5.23.tar.gz
# 重命名
mv apache-tomcat-8.5.23 tomcat
# 移动目录
mv tomcat /usr/local/tomcat8/
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tomcat常用命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 启动
/usr/local/tomcat/bin/startup.sh

# 停止
/usr/local/tomcat/bin/shutdown.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Ubuntu安装Tomcat</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/ubuntu-bi-yao-she-zhi/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu系统对网卡设置静态地址和设置时区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;ubuntu设置网卡静态地址&#34;&gt;Ubuntu设置网卡静态地址&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入网卡配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/netplan/50-cloud-init.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;network:
    ethernets:
        enp0s3:
            addresses: [10.3.133.33/24]
            gateway4: 10.3.133.1
            dhcp4: no
            dhcp6: no
            nameservers:
                addresses: [10.3.133.1,114.114.114.114]
    version: 2         
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使配置生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;netplan apply
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ubuntu设置时区&#34;&gt;Ubuntu设置时区&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;运行如下命令选择时区&lt;br&gt;
亚洲 -&amp;gt; 中国 -&amp;gt; 北京&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo tzselect
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建时区软连接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ubuntu-设置-ssh-可通过-root-用户登录&#34;&gt;Ubuntu 设置 ssh 可通过 Root 用户登录&lt;/h2&gt;
&lt;p&gt;当我们使用远程连接工具通过 root 用户登录 Ubuntu 时，会出现 &lt;code&gt;Permission denied,please try again&lt;/code&gt; 并一直让我们输入密码，出现这中情况，是因为我们系统默认禁止 root 用户 ssh 登录。解决办法如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考：&lt;a href=&#34;https://blog.csdn.net/u010867294/article/details/78109551&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;普通用户登录，并切换为 root 用户&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更改 &lt;code&gt;sshd_config&lt;/code&gt; 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找到 **#Authentication:**下的 &lt;code&gt;PermitRootLogin without-password&lt;/code&gt; 如果是没注释的则注释掉。并在下面加上一行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;PermitRootLogin yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找错 &lt;strong&gt;Authentication&lt;/strong&gt;下的 &lt;code&gt;PasswordAuthentication&lt;/code&gt; 开启密码验证&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Authentication:
 PasswordAuthentication yes //默认为no，改为yes开启密码登陆
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 ssh 服务，使配置生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Ubuntu必要设置</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;轻尘的博客，记录工作，记录生活&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/nas/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://static.chiphell.com/forum/201808/06/191741r919cyy9n55b7ppg.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">软路由的CPU</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/yun-wei-bi-ji/"" data-c="
          &lt;h2 id=&#34;运维常用命令&#34;&gt;运维常用命令&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux命令详解：&lt;code&gt;man.linuxde.net/命令名&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ifconfig&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看网络地址：&lt;code&gt;# ifconfig&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网卡配置文件：&lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网卡配置详细内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEVICE=eth0 网卡的名字

HWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址

TYPE=Ethernet 网络类型 以太网

UUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。

ONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡

NM_CONTROLLED=yes 是否受network程序管理

BOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式

　　a. dhcp 自动获取ip地址

　　b. none 固定的ip地址

　　c. static 固定的ip地址

IPADDR=10.0.0.100 IPADDR ip地址

NETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器

GATEWAY=10.0.0.2 网关 整个大楼的大门

USERCTL=no 普通用户是否能控制网卡

/etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf

DNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启网卡：&lt;code&gt;# /etc/init.d/network restart&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nameserver&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置DNS服务器：&lt;code&gt;# nameserver 8.8.8.8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;du&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示文件的大小：&lt;code&gt;# du -h 文件路径&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-h：以易读的方式显示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ps -ef&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当前系统的进程状态：&lt;code&gt;# ps -ef&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-e：显示所有程序，与‘A’效果相同
-f：显示UID,PPIP,C与STIME栏位。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭配 &lt;code&gt;grep&lt;/code&gt; 可以过滤所需要查看的进程：&lt;code&gt;# ps -ef | grep vim&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搭配 &lt;code&gt;kill&lt;/code&gt; 可结束进程：&lt;code&gt;kill PID/进程名&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实时查看系统的运行情况：&lt;code&gt;# top&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可按c、m等键按照CPU、Memory排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按q退出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df -th&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;显示磁盘分区上可使用的磁盘空间：&lt;code&gt;# df -th&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-t (--type)仅显示指定文件系统类型的磁盘信息
-h 以可读性较高的方式显示
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mount&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加载文件系统到指定的加载点：&lt;code&gt;# mount /dev/cdrom /mnt/cdrom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt; 目录下存放了外部设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt; 目录下可用于挂载外部设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tar&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;归档，压缩，解压缩等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-x    解压缩文件
-c    创建压缩文件(create)
-z	  gzip
-j	  bzip2
-v	  显示过程
-t    查看压缩包内文件
-f    (file)必备选项
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;code&gt;.tar.gz&lt;/code&gt;文件：&lt;code&gt;# tar -ztvf log.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解压&lt;code&gt;.tar.gz&lt;/code&gt;文件：&lt;code&gt;# tar -zxvf /opt/soft/test/log.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将文件打包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# tar -cvf log.tar log2012.log       仅打包，不压缩，最后一列是操作对象，也即是要打包的文件
# tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
# tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rpm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从rpm软件包安装软件：&lt;code&gt;# rpm -ivh 软件包路径&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列出所安装的rpm软件：&lt;code&gt;# rpm -qa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个rpm包中的文件安装到那里去了：&lt;code&gt;rpm -ql rpm包名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ntp-时间服务器的配置&#34;&gt;NTP 时间服务器的配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可参考：&lt;a href=&#34;https://www.cnblogs.com/jczhu/p/5851268.html&#34;&gt;火之晨曦&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装NTP服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# yum install ntp ntpdate
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/ntp.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把下列配置替换原有配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;driftfile /var/lib/ntp/drift
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
restrict 127.0.0.1
restrict -6 ::1
server 127.127.1.0		#local clock
server pool.ntp.org		#local clock
fudge 127.127.1.0 stratum 10
includefile /etc/ntp/crypto/pw
keys /etc/ntp/keys
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看NTP服务器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ntpq -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dhcp-服务器&#34;&gt;DHCP 服务器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可参考：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装DHCP服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum install dhcp dhcp-devel -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/dhcp.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;samba-服务器&#34;&gt;Samba 服务器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可参考：&lt;a href=&#34;https://www.cnblogs.com/hxgoto/p/7071175.html&#34;&gt;一如莱戈、&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装samba服务&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# yum install -y samba
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装成功后，系统会生成服务的配置文件和一些命令工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/samba/smb.conf&lt;/code&gt;  //是samba服务的主配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/init.d/smb&lt;/code&gt;             //是samba的启动/关闭文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看开机启动情况：&lt;code&gt;# service smb status&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动服务：&lt;code&gt;# service smb start&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置开机启动：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# chkconfig  --level 35 smb on      // 设置开机启动
# chkconfig --list smb				、、 查看0-6的状态，smb服务启动或关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/samba/smb.conf

配置：

[global]　　　　　　　　　　　　　　//设置samba服务整体环境

workgroup = WORKGROUP　　　　　  //设置工作组名称
server string = Samba Server Version %v     //服务器说明

[dingLinux]　　　　　　　//共享目录的名称

comment = Public stuff　　　//注释说明　
path = /usr/local/laig　　　//共享目录的路径
public = yes　　　 　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)
writeable = yes　　　　　//是yes/否no不以只读方式共享当与read only发生冲突时，无视read only
browseable = yes　      //是yes/否no在浏览资源中显示共享目录，若为否则必须指定共享路径才能存取
guest ok = yes　　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;防火墙要关闭： &lt;code&gt;# service iptables stop&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;selinux要设置成disabled，路径是：&lt;code&gt;/etc/sysconfig/selinux&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意共享目录的权限设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要设置成不需要用户名密码直接访问，需要修改配置文件，将&lt;code&gt;security&lt;/code&gt;设置成&lt;code&gt;security = share&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改配置后要重启服务：&lt;code&gt;# service smb restart&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问共享文件夹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在windows中打开文件资源管理器输入 &lt;code&gt;\\192.168.1.194&lt;/code&gt; 进行访问，ip地址根据自己的服务器地址来输入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;apache服务器安装&#34;&gt;Apache服务器安装&lt;/h2&gt;
">运维笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/xi-tong-yin-dao-xiu-fu/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;系统引导修复&#34;&gt;系统引导修复&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;进入PE系统&lt;/li&gt;
&lt;li&gt;新建一个分区，系统模式为ESP&lt;/li&gt;
&lt;li&gt;记住ESP分区对应的盘符，未分配盘符的话可 用工具进行挂载&lt;/li&gt;
&lt;li&gt;系统命令模式下，输入下列命令&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    bcdboot c:\windows /s z: /f UEFI /l zh-cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;查看引导文件是否建立成功&lt;/li&gt;
&lt;/ol&gt;
">系统引导修复</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/linux-zhi-shi-zheng-li/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;整理巩固一下Linux的知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点：多用户多任务、良好的兼容性、可移植性强、稳定性高、界面美观&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本：X.Y.Z  主版本号、次版本号(偶数是正式版本，奇数是测试版本不稳定)、修改次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统结构&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Linux系统结构&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用程序                     X  Window&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Shell层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;内核&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;Shell层：用户与内核之间的桥梁。&lt;/li&gt;
&lt;li&gt;内核：操作系统的核心，管理着整个计算机的软硬件资源。&lt;/li&gt;
&lt;li&gt;分区：至少要有两个分区  swap分区和 根分区。&lt;/li&gt;
&lt;li&gt;文件管理：ext4文件系统&lt;/li&gt;
&lt;li&gt;设备管理：
&lt;ul&gt;
&lt;li&gt;字符设备：以字符为单位进行输入输出，CPU能直接进行读写。      打印机，扫描仪，声卡、显卡、鼠标、键盘等&lt;/li&gt;
&lt;li&gt;块设备：以数据块为单位进行输入输出，CPU不能直接进行读写，要经过缓冲区。    硬盘、光盘、U盘&lt;/li&gt;
&lt;li&gt;网络设备：以数据包进行数据交换。网卡&lt;/li&gt;
&lt;li&gt;注：无论是哪类设备，Linux都统一当做文件来处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;hr&gt;
&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;命令提示符
    [root@centos  ~]#
    [ding@centos  ~]$
  用户名、主机名、目录名、提示符

命令格式
    命令名 [选项] [参数]


注销  exit    Ctrl+D
重启  reboot   shutdown -r now    注：-r的选项是reboot
关机  halt     shutdown -h now    注：-h的选项是halt 

查看时间：date
修改时间：date 184512302017     点数 月份 年
显示日历：cal  可加参数 [年份],查看全年日历

pwd 显示当前目绝对路径

cd 切换目录

ls  -l  显示详细信息(文件类型、权限、所有者、组群、文件大小、修改时间、文件名)
    -a  显示所有文件和目录

cat   显示文本文件内容
    -n 在内容前显示行号

more/less 文件   分屏显示文件(文件过长时，一屏幕一屏幕的显示)
            按空格 显示下一屏， 按回车 显示下一行， 按q 退出more命令

tail [选项] 文件    显示文本结尾部分
     -n 10 文件名  显示文件的倒数10行
head命令与tail相同

man 命令名    显示命令的手册页帮助信息，按q退出man   命令不懂找男人
命令名 --help  显示命令的帮助信息(非所有命令都有此选项)   

clear   清屏

wc [选项] 文件     按顺序显示： 行数 单词数 字符数 文件名
    -c    显示文件的字符数    char
    -l    显示文件的行数      low
    -w    显示文件的单词数    word

&amp;gt; 输出重定向   &amp;lt; 输入重定向   &amp;gt;&amp;gt; 附加输出重定向     错误重定向：结果显示在屏幕上，错误信息重定向到指定文件用  2&amp;gt;
                                                            结果和错误信息都重定向到指定文件用  &amp;amp;&amp;gt;

创建f1文件： cat &amp;gt;f1    进入输入界面，到文本的下一行按 Ctrl+D 结束输入

附加输出重定向：   cat &amp;gt;&amp;gt;f1  在f1后追加内容

管道  |  前一个命令的执行结果是后一个命令的执行条件   ls  | wc -l    统计当前目录下的文件和目录总数

history 5  查看最近执行的 5条命令 命令上限1000
!! 命令 再次执行上一条命令，!5 执行history中 5 对应的命令

别名：alias vi=&#39;vim&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vim编辑器&#34;&gt;vim编辑器&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;命令模式：刚进入vi时的模式
文本模式：i
最后行模式：按 [shift和冒号] 进入

输入文本   [命令模式下]
    i/I  a/A  o/O

查找字符串  [命令模式下]
    /字符串    从头往下找，找到则停在字符串首字母上
    ？字符串   从当前位置往下找，找到停在字符串首字母上
       n      继续查找满足条件的字符串
       N      改变查找方向，继续查找满足条件的字符串

撤销与重复   [命令模式下]
    u  撤销上一步操作
    .  重复上一步操作

文本块操作
    set nu       显示行号
    set nonu     不显示行号
    n1,n2 co n3  将 [n1,n2]行，复制到n3行之下
    n1,n2 m n3   将 [n1,n2]行，移动到n3行之下
    n1,n2 d      删除 [n1,n2]行
    n1,n2 s/字符串1/字符串2/g      将[n1,n2]行中所有的 [字符串1] 用 [字符串2] 替换

保存与退出
    [命令模式下] 连续按两次 z 保存并退出
    
    [最后行模式下]
        :w 文件  保存为指定的文件
        :q       退出，若文件有改动则提示
        :q!      不保存直接退出
        :wq      存盘并退出
        :x       存盘并退出
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;运行级别&#34;&gt;运行级别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置文件在  /etc/inittab  默认运行级别为 5&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数字&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单用户模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多用户模式，不提供NFS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;完整的多用户模式，仅提供&lt;code&gt;字符界面&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留的运行级别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;完整的多用户模式，自动启动&lt;code&gt;图形化用户界面&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重新启动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GNOME环境下：&lt;code&gt;Ctrl+Alt+[F2-F6]&lt;/code&gt; 回到字符界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符界面下：按&lt;code&gt;Alt+F1&lt;/code&gt; 回到 GNOME桌面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;用户和群组&#34;&gt;用户和群组&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;超级用户：UID 0        所属组群 GID 0
系统用户  UID 1-499    所属组群 GID 1-499
普通用户  UID 500-     所属组群 GID 500

用户账号信息文件：/etc/passwd
        文件内容：root:x:0:0:root:/root:/bin/bash
            用户名 密码 UID GID 全名 主文件夹

用户密码信息文件：/etc/shadow

组群账号信息文件：/etc/group
        文件内容：root:x:0:
                 bin:x:1:bin,daemon     组群名 组群密码 组群管理员密码  以此组群为附加组群的用户列表

组群密码信息文件：/etc/gshadow
        文件内容：root:::                     加密密码字段为 !!
                 bin:::bin,daemon     组群名 组群加密密码 组群管理员密码  以此组群为附加组群的用户列表
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt;  创建用户账号 超级用户才能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    -c  全名
    -d  主目录
    -g  指定用户的主要组群
    -G  指定用户的附加组群
    -u  指定用户的UID
    -M  只创建用户，不创建主目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt;     设置或修改密码 以及 密码属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    -d  删除用户密码
    -l  锁定用户
    -u  解除锁定
    -S  显示指定用户账号的状态
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;usermod&lt;/code&gt; [选项]  用户名    修改用户属性 超级用户才能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    -c 全名        指定用户的全称
    -d 主目录      指定用户的主目录
    -g                 指定用户的主要组群
    -G 组群ID或组群名   指定用户的附加组群
    -u 用户ID      指定用户的UID
    -l 用户名      指定用户的新名称
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;userdel&lt;/code&gt;     删除用户账号 超级用户才能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    -r  删除用户的账号和主目录，无此选项则保留主目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;su [-][用户名]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    切换用户, `-` 选项表示切换到用户的主目录    
    无用户名参数则切换到root用户
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;id [用户名]&lt;/code&gt; 查看用户的 UID、GID 和 用户所属组群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;groupadd [选项] 组群名&lt;/code&gt;    新建组群，只有超级用户才能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     -g 组群id     指定组群的GID  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;groupmod&lt;/code&gt; [选项] 组群名    新建组群，只有超级用户才能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     -g 组群id     指定组群的GID 
     -n 组群名     指定组群的新名字   
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;groupdel&lt;/code&gt; 组群名   删除组群，只有root用户才能使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;批量创建多个用户&#34;&gt;批量创建多个用户&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 students 组群&lt;br&gt;
&lt;code&gt;# groupadd -g 600 students&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建用户信息文件&lt;br&gt;
使用文本编辑器编辑 /etc/passwd   编辑好后保存为students.txt&lt;br&gt;
student1❌601:600::/home/student1:/bin/bash&lt;br&gt;
student2❌602:600::/home/student2:/bin/bash&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建用户密码,保存为password.txt&lt;br&gt;
```shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     student1:123456
     student2:123456
 ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量创建用户账号&lt;br&gt;
&lt;code&gt;# newusers &amp;lt; students.txt&lt;/code&gt;&lt;br&gt;
文件已经追加到 /etc/passwd ，系统已经在 /home 目录中为每位用户创建了主目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暂时取消 shadow 加密&lt;br&gt;
&lt;code&gt;# pwunconv&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为用户设置密码&lt;br&gt;
&lt;code&gt;# chpasswd &amp;lt; passwd.txt&lt;/code&gt;&lt;br&gt;
密码追加到了/etc/shadow  在passwd文件内能看到密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢复 shadow 加密&lt;br&gt;
&lt;code&gt;# pwconv&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批量创建的用户，主目录中都缺少 &lt;code&gt;.bash_profile&lt;/code&gt; 和 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;文件系统&#34;&gt;文件系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;挂载：将存储介质的内容映射到指定的目录，此目录为该设备的挂载点。一个挂载的点一次只能挂载一个设备&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`/etc/fstab`  保存着文件系统 开机自动挂载信息  
`/etc/mtab `  保存着当前系统中 文件系统的挂载信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件分类：普通文件、目录文件、链接文件、设备文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件布局：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;目录&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;/&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Linux目录结构的起点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bin&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放可执行命令，如chmod、data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boot&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放系统启动时所需要的文件，包括内核和引导装载程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dev&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放所有的设备文件，如cdrom光盘文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;etc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放系统配置文件，如passwd、fstab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;home&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包含所有普通用户的主目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;lib&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;包含系统二进制文件所需要的共享库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;lost+found&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放文件系统发生故障后无法归位的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;media&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;移动存储戒指的默认挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;mnt&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于临时挂载文件系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;proc&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放进程的运行信息，由内核在内存中产生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;root&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;超级用户的主目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;sbin&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放系统管理命令，一般只有超级用户才能使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;selinux&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放SELinux的相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tmp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放公用的临时文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;usr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放应用程序及相关文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;vsr&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;存放系统中经常变化的文件，如系统日志文件，用户邮件等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件扩展名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;后缀&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.rpm&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RPM软件包文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.conf&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;系统配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.lock&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;锁定文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;归档和压缩文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;后缀&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.zip&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;zip压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.tar&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;归档文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.gz&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;gzip命令产生的压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.bz2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;bzip2命令产生的压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序和脚本文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;后缀&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.c&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;C语言源程序代码文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.cpp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;C++语言源程序代码文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.o&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;程序对象文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.so&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;库文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.sh&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Shell脚本文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多媒体文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;后缀&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.gif&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;gif图像文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.jpg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GPEG图像文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.png&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;png图像文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.htm或html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;HTML超文本文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;.wav&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;音频波形文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;权限&#34;&gt;权限&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读取权限：r 、写入权限：w 、执行权限：x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字母表示法&lt;br&gt;
&lt;code&gt;- rwx rwx rwx&lt;/code&gt; 文件权限一共10个字符，中间无空格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个字符：文件类型。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;字符&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;文件类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;普通文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;目录文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;l&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;连接文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;b&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;块设备文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;c&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字符设备文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后面每三个一组，分别表示 当前用户 u，用户所在的组 g，其他 o&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字表示法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;权限&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;r/读&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;w/写&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;x/执行&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改权限&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;chmod 数字模式 文件&lt;br&gt;
&lt;code&gt;chmod 755 file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;chmod 功能模式 文件&lt;br&gt;
&lt;code&gt;chmod g-w file&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;功能模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象：&lt;br&gt;
&lt;code&gt;u&lt;/code&gt; 文件所有者 user&lt;br&gt;
&lt;code&gt;g&lt;/code&gt; 同组用户   group&lt;br&gt;
&lt;code&gt;o&lt;/code&gt; 其他用户   other&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符:&lt;br&gt;
&lt;code&gt;+&lt;/code&gt; 增加权限&lt;br&gt;
&lt;code&gt;-&lt;/code&gt; 删除权限&lt;br&gt;
&lt;code&gt;=&lt;/code&gt; 赋予权限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;权限：&lt;br&gt;
r/读：4&lt;br&gt;
w/写：2&lt;br&gt;
x/执行：1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chgrp 组群 文件&lt;/code&gt; ：改变文件所属组群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;chown 文件所有者[:组群] 文件&lt;/code&gt; ：改变文件所有者，并可一并修改文件的所属组群&lt;br&gt;
&lt;code&gt;# chown ding:ding f1&lt;/code&gt; ：把文件f1的 所有者 和 组群 一并改为 ding&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础文件命令&#34;&gt;基础文件命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建目录  mkdir&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    mkdir [选项] 目录  
            -m 创建目录的同时设置目录的访问权限
            -p 一次创建多级目录      
    例：
        mkdir -p ding/f
        rmdir -p ding/f     
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动或重命名目录   mv&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    mv [选项] 源文件或目录 目标文件或目录
        -b   若存在同名文件，则在覆盖之前备份原来的文件
        -f   强制覆盖同名文件
    例：
        mv pict picture  改名
        mv file ding/    将file文件移动到ding目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制文件或目录   cp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    cp [选项] 源文件或目录 目标文件或目录
        -b   若存在同名文件，则在覆盖之前备份原来的文件
        -f   强制覆盖同名文件
        -r/-R  按递归方式，保留原目录结构复制文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除文件或目录   rm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    rm [选项] 文件或目录
        -f      强制删除，不需要确认
        -r/-R   按递归方式删除目录
        i       再次确认是否删除
    例：
        rm -rf /*
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;立链接文件，默认硬链接  ln&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    ln [选项] 目标文件 链接文件
        -b  若存在同名，则覆盖前先备份
        -s  建立符号链接文件
    例：
        ln -s /etc/passwd passwd.lnk
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找：find 查找文件/grep 查找内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;find   查找文件或目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    find [路径] 表达式    从指定路径开始向下搜索满足表达式的文件和目录。不指定路径，则查找当前目录
        -name 文件           按文件名查找，可使用通配符       locate 与 find -name相同
        -group 组群名        查找文件所属组群为指定组群的文件
        -user 用户名         查找文件所有者为指定用户的文件
        -type 文件类型       按文件类型查找，d为目录文件，l为链接文件
        -size [+|-]文件大小  查找指定大小的文件，+ 表示超过，-表示不足
    例：     
        find -name f*   从当前目录查找 f 开头的文件
        find /etc -name fs*  
        find -type l
        find -size +100k
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grep   查找指定文件中的字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    grep [选项] 字符串 文件列表      从指定文件中查找符合条件的字符串，默认显示字符串所在的行
        -n     显示行号
        -v     显示不包含指定字符串的行
        -i     查找是不区分大小写
    例：
        grep -n root /etc/passwd   查找passwd中包含 root 的行，并显示行号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示文件大小，默认以KB为单位  du&lt;br&gt;
du [选项] [目录或文件]&lt;br&gt;
-a  显示指定目录及所有子目录和文件的大小，默认只显示目录的大小&lt;br&gt;
-h  以易读的方式显示目录或文件的大小，加上单位&lt;br&gt;
-s  只显示指定目录的大小，而不显示子目录的大小&lt;br&gt;
例：&lt;br&gt;
du -sh /home/ding&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;归档和压缩&#34;&gt;归档和压缩&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tar [] 文件名&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tar&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;选项&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;归档/压缩文件 文件或目录列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-c&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;创建归档文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示归档文件的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-x&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;还原归档文件中的目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示归档命令的执行过程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-z&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;采用gzip方式压缩/解压缩归档文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-j&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;采用bzip2方式压缩/解压缩归档文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;tar命令必须的选项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例：&lt;br&gt;
&lt;code&gt;tar -cf etc.tar /etc/*.conf&lt;/code&gt;&lt;br&gt;
&lt;code&gt;tar -czf etc.tar.gz /etc/*.conf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gzip [] 文件名&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;gzip&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;压缩或解压文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;gzip&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[选项]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件或目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;解压缩文件，相当于gunzip命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-r&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;参数为目录是，按目录结构递归压缩目录中的所有文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示文件的压缩比例&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例：&lt;br&gt;
&lt;code&gt;gzip 文件名&lt;/code&gt; 压缩或解压缩格式为 .gz的文件。压缩完后会删除源文件&lt;br&gt;
&lt;code&gt;gzip *&lt;/code&gt;    压缩当前目录所有文件，没有归档功能，压缩多个文件时每个都是.gz压缩文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bzip2 [] 文件名&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bzip2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;压缩或解压文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;bzip2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;[选项]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件或目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-d&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;解压缩文件，相当于bunzip2命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示文件的压缩比例&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;例：&lt;br&gt;
&lt;code&gt;bzip2 文件名&lt;/code&gt; 压缩或解压缩格式为 .bz2的文件。压缩完后会删除源文件&lt;br&gt;
&lt;code&gt;bzip2 *.bz2&lt;/code&gt; 解压当前文件夹所有bz2文件`&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;zip [选项] 压缩文件 文件列表&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  -m  压缩完后删除源文件
  -r  地柜压缩
  
  例：
      zip file.zip *
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unzip [选项] 压缩文件&lt;/code&gt;     解压缩.zip文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  -l       查看压缩文件所包含的文件
  -t       测试压缩文件是否已损坏
  -d 目录名   指定解压缩的目标目录 
  -n       不覆盖同名文件
  -o       强制覆盖同名文件
  例：
      unzip -d dir file.zip   解压到dir目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;rpm软件包&#34;&gt;RPM软件包&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;安装RPM软件包
    rpm -i[选项] 软件包文件
        -v      显示安装过程
        -h      以 # 表示安装进度
        -replacepkgs    重复安装软件包  

查询RPM软件包
    rpm -q[选项] 软件包
        -l      查询已安装软件包所包含的所有文件
        -i      查询已安装软件包的详细信息
        -a      查询已安装的所有软件包
        -f 文件名  查询指定文件所属的软件包

删除RPM软件包
    rpm -e 软件包
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;yum命令管理软件包&#34;&gt;YUM命令管理软件包&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;安装软件包/软件包集
    yum install 软件包名
    yum groupinstall 软件包集名

安装vsftpd软件包
    yum install vsftpd

查询软件包/软件包集信息
    yum info 软件包名
    yum groupinfo 软件包集名

查询vsftpd软件包的信息
    yum info vsftpd

删除软件包/软件包集
    yum remove 软件包名     删除RPM软件包
    yum groupremove 软件包集名     删除RPM软件包集
    yum remove vsftpd     删除vsftpd软件包
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;进程管理&#34;&gt;进程管理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程：是具有独立功能的程序的一次运行过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个程序可启动多个进程，一个进程可调用多个程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程的优先级的取值范围：-20~19&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    就绪状态：进程已获得除CPU外的运行所需的全部资源
    运行状态：进程占用CPU正在运行
    等待状态：进程正在等待某一事件或某一资源

    进程同步：相关进程为协作文成同一任务而引起的直接制约关系
    进程互斥：进程间因竞争系统资源而引起的间接制约关系
    进程死锁：对资源保持请求、对资源的循环等待、对资源的非抢占式分配、资源的独占使用

    挂起状态：正在运行的进程，因为某个原因失去CPU而暂时停止运行、
    终止状态：进程已结束
    休眠状态：进程主动暂时停止运行
    僵死状态：进程已停止运行，但是相关控制信息仍保留
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作业：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;br&gt;
正在执行的一个或多个相关进程可形成一个作业&lt;br&gt;
一个作业可启动多个进程&lt;br&gt;
作业分前台作业和后台作业&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shell的命令的末尾加上一个 &amp;amp; 符号，将启动一个后台作业&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    jobs [选项]   显示当前所有的作业
        -p     仅显示作业号
        -l     显示进程号和作业号
    bg [作业号]   将前台作业切换到后台运行，若未指定作业号，则将当前作业切换到后台
    fg [作业号]   将前台作业切换到前台运行，若未指定作业号，则将当前作业切换到前台
  
    例：
        vi f1       编辑文件f1
        Ctrl z      挂起vi
        jobs -l     显示进程号和作业号
        bg 1        将作业切换到后台
        Ctrl z      挂起vi
        fg 1        将作业再切换到前台
  
    ps [选项]     显示进程的状态，无选项时显示当前用户在当前终端启动的进程
        -a      显示当前终端上所有的进程
        -A      显示系统所有进程，包括其他用户进程和系统进程
        -l      显示进程的详细信息、包括父进程号、进程优先级等
        u       显示包括进程的所有者在内的详细信息
        x       显示后台进程的信息
        -t 终端号 显示指定终端上的进程信息
  
    pstree [选项]   以树形图显示进程之间的相互关系
            -a      显示启动进程的命令行
            -n      按照进程号进行排序
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;终止正在运行的进程，超级用户可终止所有进程，普通用户只能终止自己的进程&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    kill % 作业号
    kill [选项] 进程号    选项填数字
        HUP   1    终端断线
        INT   2    中断（同 Ctrl + C）
        QUIT  3    退出（同 Ctrl + \）
        TERM  5    终止
        KILL  9    强制终止
        CONT  8    继续（与STOP相反， fg/bg命令）
        STOP  9    暂停（同 Ctrl + Z）
    例：
        kill -9 2638   强行终止2638进程
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;进程调度&#34;&gt;进程调度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;at调度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;at [选项] [时间]
    -l  显示等待执行的调度作业
    -d  删除指定的调度作业
进程的执行时间可表示为：1.绝对计时法：HH:MM(24时制)、HH:MM(12时制加AM/PM) 日期写在时间后面，格式为：月日年
例：
    at 23:59 01012018
    at&amp;gt;wall Happy New Year!      输入at调度后会出现 at&amp;gt; 提示符， 输入完成后按 Ctrl D
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;batch调度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    在系统空间时运行，适合时间上要求不高，但运行时占系统资源较多的工作 
    输入batch还是出现 at&amp;gt; 提示符， 输入完成后按 Ctrl D
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cron调度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    at和batch调度的命令智能执行一次，cron调度能重复执行
    cron调度与crond进程、crontab命令和crontab配置文件有关
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crontab配制文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    保存在/var/spool/cron 目录中，文件名与用户名相同
    也即halen用户的crontab配置文件为/vwr/spool/crontab/helen
    crontab配置文件保留cron调度的内容，每行表示一个调度任务，每个调度任务包括六项字段
      字段：   分钟   时    日期    月份      星期          命令   (倒着：星期，月日时分)
    取值范围： 0-59  0-23  01-31   01-12  0-6(0是星期天)  
    
    &amp;quot;-&amp;quot;符号表示一段时间    &amp;quot;,&amp;quot;符号表示指定时间，如5,15,25     &amp;quot;/&amp;quot;表示时间的间隔，如日期栏中输入 */3 表示每隔三天
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;crontab [选项]   管理crontab配置文件
        -e  创建并编辑crontab配置文件
        -l  显示crontab配置文件的内容
        -r  删除crontab配置文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crond 进程&lt;br&gt;
```&lt;br&gt;
crond进程在系统启动时自动启动，并一直运行在后台，负责检测crontab配置文件，并按照其设置内容定期重复执行cron的调度工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实施系统监视的Shell命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    who [选项]   查看当前已登录的所有用户
        -H  显示出信息标题行
    
    top [-d 秒数]   动态显示CPU利用率、内存利用率和考必过状态等相关信息，默认每5s更新显示信息。-d 秒数 可以指定更新间隔
    
    free [选项]     显示内存和交换分区的使用情况
        -m    以MB为单位显示，默认以KB为单位
        -t    增加显示内存和交换分区的总数和信息

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;思考题-cron调度&#34;&gt;思考题  (cron调度)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;(1) 下午4:50删除/abc 目录下的全部子目录和全部文件
      50 16 * * * rm -rf /abc/*

(2) 早8:00--下午6:00 每小时一次将/xyz 目录下 x1 文件的最后5行加入到/backup 目录下的 back01.txt
      0 8-18 * * *  tail -5 /xyz/x1 &amp;gt;&amp;gt; /backup/back01.txt

(3) 每周一下午5:50将/data 目录下的所有目录和文件归档并压缩为文件 backup.tar.gz
      50 17 * * 1 tar -czvf backup.tar.gz /data         v是显示执行过程 
                                                        f是必带选项 
                                                        c是归档 
                                                        z是gzip压缩&lt;/code&gt;&lt;/pre&gt;
">Linux知识整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/ubuntu-python/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;学习Python，需要用Linux，这里说一下我我遇到的各种坑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;python版本更改&#34;&gt;Python版本更改&lt;/h2&gt;
&lt;p&gt;参考文章：&lt;a href=&#34;https://blog.csdn.net/fang_chuan/article/details/60958329&#34;&gt;遥远的她&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/eagleon/eagleon.github.com/issues/2&#34;&gt;GitHub Issues&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;基于用户修改版本&#34;&gt;基于用户修改版本&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查看所拥有的Python版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ls /usr/bin/python*
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看默认版本信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python --version
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改默认版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;alias python=&#39;/usr/bin/python3.6&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看是否修改成功&lt;br&gt;
重新登录或重新加载.bashrc文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;. ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看Python版本：参看上述第三步&lt;/p&gt;
 &lt;!-- more --&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vim-下-python-自动补全&#34;&gt;VIM 下 Python 自动补全&lt;/h2&gt;
&lt;h3 id=&#34;参考文章niepangu和运维笔记和xpleaf&#34;&gt;参考文章：&lt;a href=&#34;https://blog.csdn.net/niepangu/article/details/78976243&#34;&gt;niepangu&lt;/a&gt;和&lt;a href=&#34;https://blog.linuxeye.cn/324.html&#34;&gt;运维笔记&lt;/a&gt;和&lt;a href=&#34;http://blog.51cto.com/xpleaf/1682449&#34;&gt;xpleaf&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装pydictin插件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    wget https://github.com/rkulla/pydiction/archive/master.zip
    unzip -q master
    mv pydiction-master pydiction
    mkdir -p ~/.vim/tools/pydiction
    cp -r pydiction/after ~/.vim
    cp pydiction/complete-dict ~/.vim/tools/pydiction
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建~/.vimrc文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    vim ~/.vimrc
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    filetype plugin on
    let g:pydiction_location = &#39;~/.vim/tools/pydiction/complete-dict&#39;
    let g:pydiction_menu_height = 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑.py文件，测试是否成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;使用ssh连接ubuntu&#34;&gt;使用SSH连接Ubuntu&lt;/h2&gt;
&lt;h3 id=&#34;参考文章rabbittinbee&#34;&gt;参考文章：&lt;a href=&#34;https://blog.csdn.net/rabbittinbee/article/details/52422790&#34;&gt;rabbittinbee&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络连通&lt;br&gt;
Windows下查看ip cmd下:&lt;code&gt;ipconfig&lt;/code&gt;&lt;br&gt;
Ubuntu下：&lt;code&gt;ifconfig&lt;/code&gt;&lt;br&gt;
windows下ping Ubuntu的ip，查看是否ping通&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu开启SSH&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看是否开启SSH&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    ssh localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果出现下面提示表明还没有安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    ssh: connect to hostlocalhost port 22: Connection refused 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;开启SSH&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt-getinstall –y openssh-server 
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ubuntu安装fcitx使用小鹤双拼&#34;&gt;Ubuntu安装fcitx使用小鹤双拼&lt;/h2&gt;
&lt;h3 id=&#34;参考文章点击这里&#34;&gt;参考文章：&lt;a href=&#34;http://besky.me/2018/1/how-to-use-double-pinyin-with-fcitx-rime-on-ubuntu&#34;&gt;点击这里&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装fcitx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装 fcitx-rime， 是 fcitx 社区维护的
$ sudo apt-get install fcitx-rime

# 安装双拼方案
$ sudo apt-get insatll librime-data-double-pinyin

# 配置 fcitx 为默认输入法，然后重新部署或者重启
$ im-config
$ sudo reboot # (如果已经装过 fcitx 就不需要重启啦，系统托盘 fcitx 图标右键重新启动即可)

# 添加输入法
$ fcitx-config-gtk3 # (一般安装好就有了，最好确认一下)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加小鹤方案&lt;br&gt;
添加配置文件：&lt;code&gt;~/.config/fcitx/rime/default.custom.yaml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;patch:
    schema_list:
        - schema: luna_pinyin          # 朙月拼音
        - schema: luna_pinyin_simp     # 朙月拼音 简化字模式
        - schema: luna_pinyin_tw       # 朙月拼音 臺灣正體模式
        - schema: terra_pinyin         # 地球拼音 dì qiú pīn yīn
        - schema: bopomofo             # 注音
        - schema: jyutping             # 粵拼
        - schema: cangjie5             # 倉頡五代
        - schema: cangjie5_express     # 倉頡 快打模式
        - schema: quick5               # 速成
        - schema: wubi86               # 五笔 86
        - schema: wubi_pinyin          # 五笔拼音混合輸入
        - schema: double_pinyin        # 自然碼雙拼
        - schema: double_pinyin_mspy   # 微軟雙拼
        - schema: double_pinyin_abc    # 智能 ABC 雙拼
        - schema: double_pinyin_flypy  # 小鶴雙拼
        - schema: wugniu               # 吳語上海話（新派）
        - schema: wugniu_lopha         # 吳語上海話（老派）
        - schema: sampheng             # 中古漢語三拼
        - schema: zyenpheng            # 中古漢語全拼
        - schema: ipa_xsampa           # X-SAMPA 國際音標
        - schema: emoji                # emoji 表情
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vmnet0-vmnet1和vmnet8的区别&#34;&gt;VMNet0、VMNet1和VMNet8的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;vmnet0，实际上就是一个虚拟的网桥，这个网桥有很若干个端口，一个端口用于连接你的Host，一个端口用于连接你的虚拟机，他们的位置是对等的，谁也不是谁的网关。所以在Bridged模式下，你可以让虚拟机成为一台和你的Host相同地位的机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vmnet1是host-only，也就是说，选择用vmnet1的话就相当于VMware给你提供了一个虚拟交换机，仅将虚拟机和真实系统连上了，虚拟机可以与真实系统相互共享文件，但是虚拟机无法访问外部互联；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vmnet8是NAT，就是网络地址转换，相当于给你一个虚拟交换机，将虚拟机和真实系统连上去了，同时这台虚拟交换机又和外部互联网相连，这样虚拟机和真是系统可以相互共享，同时又都能访问外部互联网，而且虚拟机是借用真实系统的IP上网的，不会受到IP-MAC绑定的限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：很多人把VMnet8在宿主机比作虚拟机的路由器，这个是不对的，如果比作路由器的话，那么，虚拟机若想上网，必须把虚拟机上面的IP地址和宿主机VMnet8的ip地址相同才可以，如果那样就没有意义了，显然是不对的。所以，我们把宿主机VMnet8比作：“一个交换机，同时和外部互联网相连”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vs-code-编辑-python&#34;&gt;VS Code 编辑 Python&lt;/h2&gt;
&lt;h3 id=&#34;乱码问题&#34;&gt;乱码问题&lt;/h3&gt;
&lt;p&gt;参考文章：&lt;a href=&#34;https://www.cnblogs.com/zhaoshizi/p/9050768.html&#34;&gt;zhaoshizi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首选项中把&lt;code&gt;code-runner.executorMap&lt;/code&gt;设置为&lt;code&gt;&amp;quot;python&amp;quot;:&amp;quot;set PYTHONIOENCODING=utf-8 &amp;amp;&amp;amp; python&amp;quot;&lt;/code&gt;&lt;br&gt;
完美解决&lt;/p&gt;
&lt;h3 id=&#34;配置教程&#34;&gt;配置教程&lt;/h3&gt;
&lt;p&gt;参考文章：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/31417084&#34;&gt;浪晋&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vim下按-ctrls-后假死的解决方法&#34;&gt;VIM下按 Ctrl+s 后假死的解决方法&lt;/h2&gt;
&lt;h3 id=&#34;ctrlq-退出假死&#34;&gt;Ctrl+q 退出假死&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用vim时，如果你不小心按了 Ctrl + s后，你会发现不能输入任何东西了，像死掉了一般，其实vim并没有死掉，这时vim只是停止向终端输出而已，要想退出这种状态，只需按Ctrl + q 即可恢复正常。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;持续更新中&#34;&gt;持续更新中。。。&lt;/h2&gt;
">Ubuntu下修改Python版本</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/shuang-pin/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于有码字需求的用户来说，可能早已经厌烦了全拼的输入方式了，今天，我写篇博客，随便说一说我了解的输入法吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;不详细介绍输入法，只是我的一些推荐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;致力于让 输入法懂我们的心意&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1fvkzh6ej4tj312w0dwwg8.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;输入法推荐&#34;&gt;输入法推荐&lt;/h2&gt;
&lt;p&gt;废话不多说，直开始荐吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果能下得去决心练习，那就直接上形码输入法。关于形码输入法自己挑选吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想更容易上手，那就双拼吧，在这里我推荐小鹤双拼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小鹤双拼的进阶可以加上鹤形，基本能做到不用选字了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人经历&#34;&gt;个人经历&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我接触的输入法有全拼，双拼，五笔。很长时间以来，都是用全拼输入法，速度的话还算过得去， 但是依靠词库依旧不能摆脱选词的烦恼，可谓是苦不堪言吧！在你正畅快的输入的时候，可能眼睛还没反应过来， 文本所对应的词或句子就被你按下了空格键，等你反应过来你输入的首选上屏的文本有问题的时候你就多次按删除键， 然后一直重复着这个步骤。所以换输入法的思绪萦绕在脑海中许久，所以有了接下来五笔的学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;五笔输入法其实是一个让人又爱又恨的输入法，因为它需要投入的精力和一段时间内获得的收获简直不成正比，在我初学五笔输入法的时候，其实算是入门了吧，因为想打的字我大部分都能打出来，但是使用五笔却一直也没赶上我用全拼的时候。学五笔，背完了字根，记住了一级简码，二级简码，了解了拆分原则， 这确依旧不够，如果按时间来算的话，完成这些你只相当于完成了整个五笔历程的百分之一，或许是距离百分之一也相差甚远， 因为要提高速度需要您及其大量的时间去练习每个字的拆分，直到形成肌肉记忆，提高击键和形成肌肉记忆，这没有几十万字是下不来的。可想而知这是一个多么大的工作量了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;小鹤学习&#34;&gt;小鹤学习&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://www.flypy.com&#34;&gt;小鹤官网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双拼简介：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种建立在拼音输入法之上的输入法，可视为全拼的改进&lt;/li&gt;
&lt;li&gt;把拼音中的声母或韵母各自映射到某个按键上&lt;/li&gt;
&lt;li&gt;使得每个字音都可以用最多两次按键打出&lt;/li&gt;
&lt;li&gt;如：小：xn　鹤：he　双：ul　拼：pb&lt;/li&gt;
&lt;li&gt;相比于全拼，少了大部分击键，能极大的提升输入速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我目前所用的是小鹤音形（挂接搜狗输入法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入手的话我推荐从音形直接入手。因为这样可以节省很多选字的烦恼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暂时不想学习形码的用户也可以学习小鹤纯双拼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我于此只做一个引导，具体的折腾看你们自己的了。附上&lt;a href=&#34;http://www.flypy.com&#34;&gt;小鹤官网&lt;/a&gt;，望自主学习。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">双拼输入法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/search-engine/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;记录一些搜索引擎使用技巧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;具体使用&#34;&gt;具体使用&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;表达式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;用途&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;“”(双引号)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索词放在双引号中，代表完全匹配搜索&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;“keyword”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;*（通配符）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;代表任何文字，比如想查找“锤*手机&amp;quot;，可以搜索到锤子手机，锤xx手机等&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;“锤*手机”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;+（与）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索所有包含关键词“keyword1”和“keyword2**”的中文网页&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;“keyword1 keyword2” 或者“keyword1+keyword2”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-（非）(A -B)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索去除keyword2的keyword1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;“keyword1 -keyword2”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;OR(或)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索 A 或者 B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;“keyword1 OR keyword2”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;~keyword1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索它的同义词&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;~喜欢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;~keyword1-keyword2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只搜索同义词,不要原词&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;~WORD-WORD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;site:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索指定域名的内容&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;site:www.github.com keyword 或者keyword site:www.github.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;filetype:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限制搜索的词语是网页中链接内包含的关键词&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;filetype:pdf ios开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;link:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索网页中含有某链接的结果,实例中的结果为包含百度这个链接的页面&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;link:http://baidu.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;inurl:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索网站地址中包含关键词词的结果&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inurl:搜索引擎优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;intitle&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索标题中包含关键词词的结果&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;intitle:搜索引擎优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;related:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;搜索相关网站&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;related:qidian.com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;intext:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限制搜索的词语是网页内文包含的关键词&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index of&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;根据输入的内容返回一些资源列表&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;index of mp3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;inanchor:keyword&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指令返回的结果是导入链接锚文字中包含搜索词的页面&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;inanchor:关于我们&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;-filetype:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-filetype:SOMEFILETYPE = 剔除指定文件类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-filetype:SOMEFILETYPE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allinanchor:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限制搜索的词语是网页中链接内包含的关键词（可使用多个关键词）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;allinanchor:keyword1 keyword2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;allintext:&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限制搜索的词语是网页内文包含的关键词（可使用多个关键词）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;allintext:keyword1 keyword2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">搜索引擎使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://dgzd.github.io/post/git/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;随便整理的一些自用的Git指令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;github创建仓库提示代码&#34;&gt;GitHub创建仓库提示代码&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;# 项目名&amp;quot; &amp;gt;&amp;gt; README.md
git init
git add README.md
git commit -m &amp;quot;first commit&amp;quot;
git remote add origin git@github.com:qiubaiying/项目名.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若仓库存在直接push&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin git@github.com:qiubaiying/test.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用操作&#34;&gt;常用操作&lt;/h2&gt;
&lt;h3 id=&#34;生成-ssh-key-详细-csdn&#34;&gt;生成 SSH Key, 详细: &lt;a href=&#34;https://blog.csdn.net/xiehd313/article/details/81110551&#34;&gt;CSDN&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;生成多个 SSH Key 并重命名(生成一个则不需要 f 选项)
$ ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot; -f ~/.ssh/id_rsa_github
$ ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot; -f ~/.ssh/id_rsa_gitlab
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建仓库初始化&#34;&gt;创建仓库（初始化）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在当前指定目录下创建
git init

新建一个仓库目录
git init [project-name]

克隆一个远程项目
git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加文件到缓存区&#34;&gt;添加文件到缓存区&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;添加所有变化的文件
git add .

添加名称指定文件
git add text.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;设置提交代码时的用户信息
git config [--global] user.name &amp;quot;[name]&amp;quot;
git config [--global] user.email &amp;quot;[email address]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提交&#34;&gt;提交&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;提交暂存区到仓库区
git commit -m &amp;quot;msg&amp;quot;

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;远程同步&#34;&gt;远程同步&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分支&#34;&gt;分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;标签tags&#34;&gt;标签Tags&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;添加标签 在当前commit
git tag -a v1.0 -m &#39;xxx&#39; 

添加标签 在指定commit
git tag v1.0 [commit]

查看
git tag

删除
git tag -d V1.0

删除远程tag
git push origin :refs/tags/[tagName]

推送
git push origin --tags

拉取
git fetch origin tag V1.0

新建一个分支，指向某个tag
git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看信息&#34;&gt;查看信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&amp;quot;提交说明&amp;quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &amp;quot;@{0 day ago}&amp;quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;撤销&#34;&gt;撤销&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 生成一个可供发布的压缩包
$ git archives&lt;/code&gt;&lt;/pre&gt;
">Git 指令</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;消息队列简介&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;什么是消息队列\&#34;&gt;什么是消息队列&lt;/h2&gt;\n&lt;p&gt;例如：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;服务员点菜快，厨师做菜慢，服务员只需要给厨师点菜单即可，然后就可以继续去服务谷歌，不需要等待厨师把菜做完。点菜单就相当于消息，放单子的位置就相当少队列。&lt;/li&gt;\n&lt;li&gt;业务系统需要发短信，但短信发送模块速度跟不上，业务系统就可以吧发送短信的两个人信息封装为一个消息，放入队列，短信发送模块从队列中获取消息进行处理&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;MQ，是一种跨进程的通信机制，用于上下游传递消息。&lt;/p&gt;\n&lt;p&gt;在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。&lt;/p&gt;\n&lt;p&gt;使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://blog.csdn.net/qq_35152037/article/details/80012961\&#34;&gt;使用场景&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;消息队列（Message Queue）是一种不同应用程序之间（跨进程）的通信方式。应用程序通过写入和检索出入列队的数据（消息）来通信，而无需通过专用链接来连接它们。&lt;/p&gt;\n&lt;p&gt;消息发送后可以立即返回，由消息系统来确保信息的可靠传递，消息发布者只管把消息发布到 MQ 中而不管谁来取，消息使用者只管从 MQ 中区消息而不管谁发布的，发布者和使用者都不知道对方的存在&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;直接调用通常是用于诸如 &lt;strong&gt;远程过程调用&lt;/strong&gt; (Remote Procedure Call. RPC)的技术。&lt;/p&gt;\n&lt;p&gt;排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求，这样天然的就实现了异步的目标。&lt;/p&gt;\n&lt;h2 id=\&#34;为什么要使用消息队列\&#34;&gt;为什么要使用消息队列&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;解耦、异步、削峰&lt;/li&gt;\n&lt;li&gt;参考：&lt;a href=\&#34;https://blog.csdn.net/weixin_40753536/article/details/82383304\&#34;&gt;为什么要使用 MQ&lt;/a&gt;、&lt;a href=\&#34;https://blog.csdn.net/qq_34288630/article/details/79411529\&#34;&gt;什么是消息队列&lt;/a&gt;、&lt;a href=\&#34;https://www.liangzl.com/get-article-detail-1992.html\&#34;&gt;消息队列的功能场景 - 京东技术&lt;/a&gt; 、&lt;a href=\&#34;https://blog.csdn.net/alinshen/article/details/80583214\&#34;&gt;消息队列会遇到的问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;解耦\&#34;&gt;解耦&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;传统模式的缺点&lt;/strong&gt;：系统间耦合性太强，&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;中间件模式的优点&lt;/strong&gt;：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而实现解耦。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g1om5zqkf1j30hi06xmy0.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：订单系统生成订单，推送到 MQ 后立即返回，结算系统从 MQ 拉取订单并处理&lt;/p&gt;\n&lt;p&gt;MQ最直接的使用场景就是可以将两个系统进行解耦，比如我们的货款抵扣业务场景，用户生成订单发送MQ后立即返回，结算系统去消费该MQ进行用户账户金额的扣款。这样订单系统只需要关注把订单创建成功，最大可能的提高订单量，并且生成订单后立即返回用户。而结算系统重点关心的是账户金额的扣减，保证账户金额最终一致。这个场景里面还会涉及到重试幂等性问题&lt;/p&gt;\n&lt;h3 id=\&#34;异步\&#34;&gt;异步&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;传统模式&lt;/strong&gt;：一些非必要的业务逻辑以同步的方式运行，太耗费时间。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;中间件模式&lt;/strong&gt;：将消息写入消息队列，使非必要的业务逻辑以异步的方式运行，加快响应速度&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：订单系统&lt;/p&gt;\n&lt;p&gt;用户点击 【下单】按钮后的业务逻辑包括：扣减库存、生成相应的订单数据、下单、发送消息通知等&lt;/p&gt;\n&lt;p&gt;在业务发展的初期，这些逻辑可能放在一起同步执行，但随着业务的整张，，需要提升系统服务的性能，这时候可以将一些不需要立即生效的操作拆分出来异步执行，比如发送消息等。这种场景就可以使用 MQ，在下单的主流程(比如扣减库存、生成相应的单据) 完成之后，发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取 MQ 的消息 ( 或者让 MQ 推送消息 )&lt;/p&gt;\n&lt;p&gt;上述订单系统中，把下单后发送消息通知存放到 MQ ，通过另外的线程单独调用，就是异步的体现&lt;/p&gt;\n&lt;h3 id=\&#34;削峰\&#34;&gt;削峰&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;传统模式&lt;/strong&gt;：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;中间件模式&lt;/strong&gt;：把要处理的请求放入MQ，系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;业务中的使用场景&lt;/strong&gt;：平衡高并发时期的流量&lt;/p&gt;\n&lt;p&gt;还是以订单系统和结算系统场景为例，如果订单系统通过RPC框架来调用结算系统，在有高峰促销的情况下生成订单的量会非常大，而且由于生成订单的速度也非常快，这样势必会给结算系统造成系统压力，服务器利用率则会偏高，但在不是高峰的时间点订单量比较小，结算系统的服务器利用率则会偏低。&lt;/p&gt;\n&lt;h2 id=\&#34;消息队列的优缺点\&#34;&gt;消息队列的优缺点&lt;/h2&gt;\n&lt;p&gt;参考：&lt;a href=\&#34;https://blog.csdn.net/qq_34288630/article/details/79411529\&#34;&gt;什么是消息队列&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;为什么要分布式消息队列\&#34;&gt;为什么要分布式消息队列&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;多系统协作需要分布式&lt;/p&gt;\n&lt;p&gt;例如消息队列的数据需要在多个系统之间共享，所以需要提供分布式通信机制，协同机制&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可靠&lt;/p&gt;\n&lt;p&gt;消息会被持久化到分布式存储中，这样避免了单台机器存储的消息由于机器问题导致的消息丢失&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可扩展&lt;/p&gt;\n&lt;p&gt;分布式消息队列，会随着访问量的增加而方便的增加处理服务器&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;优点\&#34;&gt;优点&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;提高系统响应速度&lt;/p&gt;\n&lt;p&gt;使用消息队列，生产者一方把消息往消息队列里一扔，就可以立马返回响应用户，无需等待处理结果&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;保证消息的传递&lt;/p&gt;\n&lt;p&gt;如果发送消息时接收者不可用，消息队列就会保留消息，直到成功的传递它&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;解耦&lt;/p&gt;\n&lt;p&gt;只要信息格式不变，即使接收者的接口、位置、或者配置改变，也不会给发送者带来任何改变&lt;br&gt;\n消息发送者无需知道消息接收者是谁，使得系统设计更清晰&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;缺点\&#34;&gt;缺点&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;系统可用性降低&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;系统复杂性增加&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。&lt;/p&gt;\n&lt;p&gt;但是，我们该用还是要用的。&lt;/p&gt;\n&lt;h2 id=\&#34;常见问题\&#34;&gt;常见问题&lt;/h2&gt;\n&lt;p&gt;参考：&lt;a href=\&#34;https://blog.csdn.net/alinshen/article/details/80583214\&#34;&gt;消息队列会遇到的问题&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;如何保证消息队列是高可用\&#34;&gt;如何保证消息队列是高可用&lt;/h3&gt;\n&lt;p&gt;分析：引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。&lt;br&gt;\n回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。&lt;br&gt;\n以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。&lt;/p&gt;\n&lt;p&gt;至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。&lt;br&gt;\n要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。&lt;/p&gt;\n&lt;h3 id=\&#34;如何保证消息不被重复消费\&#34;&gt;如何保证消息不被重复消费&lt;/h3&gt;\n&lt;p&gt;这个问题其实换一种问法就是 —— 如何保证消息队列的幂等性?&lt;/p&gt;\n&lt;p&gt;这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。&lt;/p&gt;\n&lt;p&gt;先来说一下为什么会造成重复消费?&lt;/p&gt;\n&lt;p&gt;其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因，就是&lt;strong&gt;因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;如何解决?这个问题针对业务场景来答分以下几点&lt;/p&gt;\n&lt;p&gt;1. 比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。&lt;br&gt;\n  2. 再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。&lt;br&gt;\n  3. 如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;/p&gt;\n&lt;h3 id=\&#34;如何保证消费的可靠性传输\&#34;&gt;如何保证消费的可靠性传输&lt;/h3&gt;\n&lt;p&gt;其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;生产者弄丢数据&lt;/p&gt;\n&lt;p&gt;从生产者弄丢数据来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢失消息&lt;/p&gt;\n&lt;p&gt;transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。&lt;/p&gt;\n&lt;p&gt;然而缺点就是吞吐量下降了。生产上用confirm模式的居多&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;消息队列弄丢数据&lt;/p&gt;\n&lt;p&gt;针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。&lt;/p&gt;\n&lt;p&gt;开启持久化磁盘的配置。这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 ACK 信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;消费者弄丢数据&lt;/p&gt;\n&lt;p&gt;消费者丢失数据一般是因为采用了自动确认消息模式。这种模式下消费者会自动确认收到消息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;如何保证消息的顺序性\&#34;&gt;如何保证消息的顺序性&lt;/h3&gt;\n&lt;p&gt;通过某种算法，&lt;strong&gt;将需要保持先后顺序的消息放到同一个消息队列中&lt;/strong&gt; (kafka中就是partition,rabbitMq中就是queue)。&lt;strong&gt;然后只用一个消费者去消费该队列&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？&lt;/p&gt;\n&lt;p&gt;这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。&lt;br&gt;\n总之，针对这个问题，我的观点是&lt;strong&gt;保证入队有序就行，出队以后的顺序交给消费者自己去保证&lt;/strong&gt;，没有固定套路。&lt;/p&gt;\n&lt;h2 id=\&#34;消息队列选型\&#34;&gt;消息队列选型&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;mq&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;消息队列简介&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;消息队列&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;GMzyxFnFy&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/GMzyxFnFy/&#34;}],&#34;date&#34;:&#34;2019-03-28 09:44:54&#34;,&#34;dateFormat&#34;:&#34;2019-03-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/mq/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:659000,&#34;words&#34;:3239,&#34;minutes&#34;:11},&#34;description&#34;:&#34;前言\n\n消息队列简介\n\n\n什么是消息队列\n例如：\n\n服务员点菜快，厨师做菜慢，服务员只需要给厨师点菜单即可，然后就可以继续去服务谷歌，不需要等待厨师把菜做完。点菜单就相当于消息，放单子的位置就相当少队列。\n业务系统需要发短信，但短信发送模块...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\&#34;&gt;什么是消息队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\&#34;&gt;为什么要使用消息队列&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E8%80%A6\&#34;&gt;解耦&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E6%AD%A5\&#34;&gt;异步&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8A%E5%B3%B0\&#34;&gt;削峰&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\&#34;&gt;消息队列的优缺点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\&#34;&gt;为什么要分布式消息队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9\&#34;&gt;优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E7%82%B9\&#34;&gt;缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98\&#34;&gt;常见问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8\&#34;&gt;如何保证消息队列是高可用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9\&#34;&gt;如何保证消息不被重复消费&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93\&#34;&gt;如何保证消费的可靠性传输&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7\&#34;&gt;如何保证消息的顺序性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B\&#34;&gt;消息队列选型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;关于 Docker、Dockerfile、docker-compose 简单概述&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;docker\&#34;&gt;Docker&lt;/h1&gt;\n&lt;h2 id=\&#34;简介\&#34;&gt;简介&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;Docker 是一种容器技术，作用是用来快速部署服务&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;docker-解决了什么问题\&#34;&gt;Docker 解决了什么问题&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Docker解决了运行环境和配置问题，方便发布，也就方便做持续集成&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;更轻量的虚拟化，节省了虚拟机的性能损耗&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;docker-应用场景\&#34;&gt;Docker 应用场景&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;程序分发，gitlab的安装很恶心吧，所以有人做了gitlab的image&lt;/li&gt;\n&lt;li&gt;部署发布，可以很好的解决环境和配置问题&lt;/li&gt;\n&lt;li&gt;PaaS，tsuru、flynn都是基于Docker的，CloudFoundry也要从warden迁移到Docker，不解释&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;容器的启动过程\&#34;&gt;容器的启动过程&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;docker client(即：docker终端命令行)会调用docker daemon请求启动一个容器，&lt;/li&gt;\n&lt;li&gt;docker daemon会向host os(即：linux)请求创建容器&lt;/li&gt;\n&lt;li&gt;linux会创建一个空的容器（可以简单理解为：一个未安装操作系统的裸机，只有虚拟出来的CPU、内存等硬件资源）&lt;/li&gt;\n&lt;li&gt;docker daemon请检查本机是否存在docker镜像文件（可以简单理解为操作系统安装光盘），如果有，则加载到容器中（即：光盘插入裸机，准备安装操作系统）&lt;/li&gt;\n&lt;li&gt;将镜像文件加载到容器中（即：裸机上安装好了操作系统，不再是裸机状态）&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;docker-安装和基础命令\&#34;&gt;Docker 安装和基础命令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;请阅读：&lt;a href=\&#34;https://ding.gq/Ubuntu%E5%AE%89%E8%A3%85Docker.html#more\&#34;&gt;Ubuntu 安装及使用 Docker&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;dockerfile\&#34;&gt;Dockerfile&lt;/h1&gt;\n&lt;h2 id=\&#34;简介-2\&#34;&gt;简介&lt;/h2&gt;\n&lt;p&gt;Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此没一条指令的内容，就是描述该层应当如何构建&lt;/p&gt;\n&lt;h2 id=\&#34;命令详解\&#34;&gt;命令详解&lt;/h2&gt;\n&lt;h3 id=\&#34;from\&#34;&gt;FROM&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;指定基础镜像&lt;/strong&gt;。必备指令，必须是 Dockerfile 文件的第一条指令&lt;/p&gt;\n&lt;h3 id=\&#34;run\&#34;&gt;RUN&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;执行命令&lt;/strong&gt;。命令有两种书写格式&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;shell 格式：&lt;code&gt;RUN&lt;/code&gt; 后直接书写命令，就像在 shell 中一样&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;exec 格式：&lt;code&gt;RUN [&amp;quot;可执行文件&amp;quot;, &amp;quot;参数1&amp;quot;, &amp;quot;参数2&amp;quot;]&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;RUN [&amp;quot;chmod&amp;quot;,&amp;quot;+x&amp;quot;,&amp;quot;start.sh&amp;quot;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;copy\&#34;&gt;COPY&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;复制文件&lt;/strong&gt;。把文件从本机 &lt;code&gt;上下文目录中&lt;/code&gt; 复制到容器中，和 &lt;code&gt;RUN&lt;/code&gt;指令 一样有两种格式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;# 格式1\nCOPY package.json /usr/src/app/\n\n# 格式2\nCOPY [&amp;quot;package.json&amp;quot;,&amp;quot;/usr/src/app/&amp;quot;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;add\&#34;&gt;ADD&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;更高级的复制命令&lt;/strong&gt;。和 &lt;code&gt;COPY&lt;/code&gt; 的使用格式一致，但在其基础上加了一些功能&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;源路径可以是 URL，Docker 引擎会去下载链接文件放到目标路径，并设置权限为 &lt;code&gt;600&lt;/code&gt; ，不如直接使用 &lt;code&gt;RUN&lt;/code&gt; 指令配合 &lt;code&gt;wget&lt;/code&gt; 或 &lt;code&gt;curl&lt;/code&gt;，所以&lt;strong&gt;不推荐使用&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;如果 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 为一个 &lt;code&gt;tar&lt;/code&gt; 压缩文件的话，压缩格式为 &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的情况下，&lt;code&gt;ADD&lt;/code&gt; 指令将会自动解压缩这个压缩文件到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;cmd\&#34;&gt;CMD&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;容器启动时运行命令&lt;/strong&gt;。命令格式和 &lt;code&gt;RUN&lt;/code&gt; 相似，在容器启动是会执行 CMD 所指定的命令&lt;/p&gt;\n&lt;h3 id=\&#34;entrypoint\&#34;&gt;ENTRYPOINT&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;指定容器启动时要运行的命令&lt;/strong&gt;。目的和 &lt;code&gt;CMD&lt;/code&gt; 一样，格式也是 &lt;code&gt;RUN&lt;/code&gt; 指令的格式&lt;/p&gt;\n&lt;p&gt;但当指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的含义就发生了改变，不再是直接的运行其命令，而是将 &lt;code&gt;CMD&lt;/code&gt; 的内容作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令，换句话说实际执行时，将变为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;&amp;lt;ENTRYPOINT&amp;gt; &amp;quot;&amp;lt;CMD&amp;gt;&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;env\&#34;&gt;ENV&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;设置环境变量&lt;/strong&gt;。在 Dockerfile 文件中设置环境变量，让下面的内容可以引用&lt;/p&gt;\n&lt;p&gt;无论是后面的其它指令，如 &lt;code&gt;RUN&lt;/code&gt;，还是运行时的应用，都可以直接使用这里定义的环境变量。&lt;/p&gt;\n&lt;p&gt;例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;ENV NODE_VERSION 7.2.0\n\n# 可多次引用上面所定义的环境变量\nRUN curl -SLO &amp;quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&amp;quot; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;arg\&#34;&gt;ARG&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;构建参数&lt;/strong&gt;。效果和 &lt;code&gt;ENV&lt;/code&gt; 一样，都是设置环境变量&lt;/p&gt;\n&lt;p&gt;所不同的是，&lt;code&gt;ARG&lt;/code&gt; 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 &lt;code&gt;ARG&lt;/code&gt; 保存密码之类的信息，因为 &lt;code&gt;docker history&lt;/code&gt; 还是可以看到所有值的。&lt;/p&gt;\n&lt;h3 id=\&#34;volume\&#34;&gt;VOLUME&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;定义匿名卷&lt;/strong&gt;。把容器中的目录挂载出来作为匿名卷，当向容器中写入数据时，不会写入容器中，会写入在本地的卷中&lt;/p&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;# 把某一个目录挂载为匿名卷\nVOLUME &amp;lt;路径&amp;gt;\n\n#挂载多个目录为匿名卷\nVOLUME [&amp;quot;&amp;lt;路径1&amp;gt;&amp;quot;, &amp;quot;&amp;lt;路径2&amp;gt;&amp;quot;...]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;VOLUME /data\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里的 &lt;code&gt;/data&lt;/code&gt; 目录就会在运行时自动挂载为匿名卷，任何向 &lt;code&gt;/data&lt;/code&gt; 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker run -d -v mydata:/data xxxx\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这行命令中，就使用了 &lt;code&gt;mydata&lt;/code&gt; 这个命名卷挂载到了 &lt;code&gt;/data&lt;/code&gt; 这个位置，替代了 &lt;code&gt;Dockerfile&lt;/code&gt; 中定义的匿名卷的挂载配置。&lt;/p&gt;\n&lt;h3 id=\&#34;expose\&#34;&gt;EXPOSE&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;暴露端口&lt;/strong&gt;。声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务&lt;/p&gt;\n&lt;p&gt;在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 &lt;code&gt;docker run -P&lt;/code&gt;时，会自动随机映射 &lt;code&gt;EXPOSE&lt;/code&gt; 的端口。&lt;/p&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;...]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;workdir\&#34;&gt;WORKDIR&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;指定工作目录&lt;/strong&gt;。指定工作目录（或者称为当前目录）以后，各层的当前目录就被改为指定的目录，如该目录不存在，&lt;code&gt;WORKDIR&lt;/code&gt; 会帮你建立目录。&lt;/p&gt;\n&lt;h3 id=\&#34;user\&#34;&gt;USER&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;指定当前用户&lt;/strong&gt;。和 &lt;code&gt;WORKDIR&lt;/code&gt; 相似，都是改变环境状态并影响以后的层。&lt;code&gt;WORKDIR&lt;/code&gt; 是改变工作目录，&lt;code&gt;USER&lt;/code&gt;则是改变之后层的执行 &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;CMD&lt;/code&gt; 以及 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 这类命令的身份。&lt;/p&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;USER &amp;lt;用户名&amp;gt;[:&amp;lt;用户组&amp;gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;healthcheck\&#34;&gt;HEALTHCHECK&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;格式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;HEALTHCHECK [选项] CMD &amp;lt;命令&amp;gt; # 设置检查容器健康状况的命令\n\nHEALTHCHECK NONE    # 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;onbuild\&#34;&gt;ONBUILD&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;为他人做嫁衣&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;ONBUILD&lt;/code&gt; 是一个特殊的指令，它后面跟的是其它指令，比如 &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt; 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。&lt;/p&gt;\n&lt;h1 id=\&#34;docker-compose\&#34;&gt;Docker Compose&lt;/h1&gt;\n&lt;h2 id=\&#34;简介-3\&#34;&gt;简介&lt;/h2&gt;\n&lt;p&gt;Docker Compose 是用来对 docker 容器编排，把所有繁复的 docker 操作全都一条命令，自动化的完成。&lt;/p&gt;\n&lt;h2 id=\&#34;安装\&#34;&gt;安装&lt;/h2&gt;\n&lt;p&gt;在 Linux 上安装十分简单。从 &lt;a href=\&#34;https://github.com/docker/compose/releases\&#34;&gt;官方 GitHub Release&lt;/a&gt; 处直接下载编译好的二进制文件即可。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -L https://github.com/docker/compose/releases/download/1.24.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n\nchmod +x /usr/local/bin/docker-compose\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;卸载\&#34;&gt;卸载&lt;/h2&gt;\n&lt;p&gt;如果是二进制包安装的，删除二进制包即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;$ sudo rm /usr/local/bin/docker-compose\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;compose-模板文件\&#34;&gt;Compose 模板文件&lt;/h2&gt;\n&lt;p&gt;MySQL + Nginx + Tomcat 的商城项目&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-yaml\&#34;&gt;version: &#39;3&#39;\nservices:\n  tomcat:\n    restart: always\n    build:\n      context: ./bookstore_admin\n      dockerfile: tomcat_dockerfile\n    image: tomcat\n    container_name: tomcat\n    ports:\n      - 8080:8080\n    networks:\n      - my_net\n    environment:\n      TZ: Asia/Shanghai\n\n  nginx:\n    restart: always\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:80\n    networks:\n       - my_net\n    volumes:\n      - ./conf/nginx.conf:/etc/nginx/nginx.conf\n      - ./wwwroot:/usr/share/nginx/wwwroot\n\n  db:\n    restart: always\n    build:\n      context: ./bookstore_db\n      dockerfile: Dockerfile\n    container_name: mysql\n    ports:\n      - 3306:3306\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ROOT_PASSWORD: root\n    command:\n      --character-set-server=utf8mb4\n      --collation-server=utf8mb4_general_ci\n      --explicit_defaults_for_timestamp=true\n      --lower_case_table_names=1\n      --max_allowed_packet=128M\n      --sql-mode=&amp;quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&amp;quot;\n    volumes:\n      - ./data/mysql:/var/lib/mysql\n    networks:\n      - my_net\n\nnetworks:\n  my_net:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 172.30.0.1/16\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;docker-compose常用命令\&#34;&gt;Docker Compose常用命令&lt;/h2&gt;\n&lt;h3 id=\&#34;build\&#34;&gt;build&lt;/h3&gt;\n&lt;p&gt;构建（重新构建）项目中的服务容器。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker-compose build -f yml文件\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;up\&#34;&gt;up&lt;/h3&gt;\n&lt;p&gt;构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker-compose -f yml文件 up \n\n# -d 以守护进程运行\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;down\&#34;&gt;down&lt;/h3&gt;\n&lt;p&gt;停止up 命令启动的容器并&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker-compose -f xx.yml down\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;logs\&#34;&gt;logs&lt;/h3&gt;\n&lt;p&gt;查看服务容器的输出。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker-compose logs [options] [SERVICE...]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;rm\&#34;&gt;rm&lt;/h3&gt;\n&lt;p&gt;删除所有（停止状态的）服务容器。推荐先执行 &lt;code&gt;docker-compose stop&lt;/code&gt; 命令来停止容器。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker-compose rm [options] [SERVICE...]\n\n# -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。\n# -v  删除容器所挂载的数据卷\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;其他命令\&#34;&gt;其他命令&lt;/h3&gt;\n&lt;p&gt;请查看 &lt;a href=\&#34;https://yeasy.gitbooks.io/docker_practice/compose/commands.html\&#34;&gt;Docker从入门到实战&lt;/a&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;docker-网络设置\&#34;&gt;Docker 网络设置&lt;/h1&gt;\n&lt;h2 id=\&#34;查看-docker-的网卡\&#34;&gt;查看 docker 的网卡&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;$ docker network ls\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Docker安装后，默认会创建下面三种网络类型&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;bridge：桥接网络&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;默认情况下启动的 Docker 容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker 的 IP 地址就变了&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;host：主机网络&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;使用 &lt;code&gt;--network=host&lt;/code&gt; ，此时，Docker 容器的网络会附属在主机上，两者是互通的。&lt;br&gt;\n例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;none：无指定网络&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;使用 &lt;code&gt;--network=none&lt;/code&gt; ，docker 容器就不会分配局域网的IP&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;启动-docker时指定网络类型\&#34;&gt;启动 Docker时指定网络类型&lt;/h2&gt;\n&lt;p&gt;在 docker 容器启动时，把容器加入指定的网络，使用 &lt;code&gt;--network 网络类型&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker run -itd --name test1 --network bridge --ip 172.17.0.10 centos:latest /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;创建自定义网络为容器设置固定ip\&#34;&gt;创建自定义网络：（为容器设置固定IP）&lt;/h2&gt;\n&lt;p&gt;启动 Docker 容器的时候，使用默认的网络是不支持指派固定IP的，如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker run -itd --net bridge --ip 172.17.0.10 centos:latest /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;会出现错误提示：&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;docker: Error response from daemon: User specified IP address is supported on user defined networks only.&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;解决方式如下&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;创建自定义网络&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker network create --subnet=172.18.0.0/16 mynetwork\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建 Docker 容器&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-dockerfile\&#34;&gt;docker run -itd --name networkTest1 --net mynetwork --ip 172.18.0.2 centos:latest /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;注：当使用 docker-conpose 文件时，可以在 compose 文件中设置容器的网络&lt;/p&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/neptunemoon/p/6512121.html#toc_2\&#34;&gt;neptune 破壁人&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.cnblogs.com/xuezhigu/p/8257129.html\&#34;&gt;雪之谷&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://yeasy.gitbooks.io/docker_practice/image/build.html\&#34;&gt;Docker从入门到实战&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;docker-gai-shu&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;关于 Docker、Dockerfile、docker-compose 简单概述&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Docker 概述&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Docker&#34;,&#34;slug&#34;:&#34;hOA1U8UfK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/hOA1U8UfK/&#34;}],&#34;date&#34;:&#34;2019-03-14 20:46:13&#34;,&#34;dateFormat&#34;:&#34;2019-03-14&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/docker-gai-shu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:620000,&#34;words&#34;:2622,&#34;minutes&#34;:11},&#34;description&#34;:&#34;前言\n\n关于 Docker、Dockerfile、docker-compose 简单概述\n\n\nDocker\n简介\nDocker 是一种容器技术，作用是用来快速部署服务\nDocker 解决了什么问题\n\nDocker解决了运行环境和配置问题，方...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker\&#34;&gt;Docker&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\&#34;&gt;Docker 解决了什么问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;Docker 应用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\&#34;&gt;容器的启动过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4\&#34;&gt;Docker 安装和基础命令&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dockerfile\&#34;&gt;Dockerfile&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B-2\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3\&#34;&gt;命令详解&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#from\&#34;&gt;FROM&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#run\&#34;&gt;RUN&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#copy\&#34;&gt;COPY&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#add\&#34;&gt;ADD&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cmd\&#34;&gt;CMD&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#entrypoint\&#34;&gt;ENTRYPOINT&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#env\&#34;&gt;ENV&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#arg\&#34;&gt;ARG&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#volume\&#34;&gt;VOLUME&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#expose\&#34;&gt;EXPOSE&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#workdir\&#34;&gt;WORKDIR&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#user\&#34;&gt;USER&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#healthcheck\&#34;&gt;HEALTHCHECK&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#onbuild\&#34;&gt;ONBUILD&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-compose\&#34;&gt;Docker Compose&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B-3\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85\&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%B8%E8%BD%BD\&#34;&gt;卸载&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#compose-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6\&#34;&gt;Compose 模板文件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\&#34;&gt;Docker Compose常用命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#build\&#34;&gt;build&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#up\&#34;&gt;up&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#down\&#34;&gt;down&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#logs\&#34;&gt;logs&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rm\&#34;&gt;rm&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4\&#34;&gt;其他命令&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE\&#34;&gt;Docker 网络设置&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8B-docker-%E7%9A%84%E7%BD%91%E5%8D%A1\&#34;&gt;查看 docker 的网卡&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8-docker%E6%97%B6%E6%8C%87%E5%AE%9A%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B\&#34;&gt;启动 Docker时指定网络类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E4%B8%BA%E5%AE%B9%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%9B%BA%E5%AE%9Aip\&#34;&gt;创建自定义网络：（为容器设置固定IP）&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;简述TCP的三次握手和四次挥手。一些个人的简单理&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;tcp-的六种标志位\&#34;&gt;TCP 的六种标志位&lt;/h2&gt;\n&lt;h3 id=\&#34;syn-同步标志\&#34;&gt;SYN 同步标志&lt;/h3&gt;\n&lt;p&gt;同步序列编号（&lt;strong&gt;Synchronize Sequence Numbers&lt;/strong&gt;）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。&lt;/p&gt;\n&lt;h3 id=\&#34;ack确认标志\&#34;&gt;ACK：确认标志&lt;/h3&gt;\n&lt;p&gt;确认编号（&lt;strong&gt;Acknowledgement Number&lt;/strong&gt;）在数据通信中，接收站发给发送站的一种传输类&lt;a href=\&#34;https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704\&#34;&gt;控制字符&lt;/a&gt;。表示发来的数据已确认接收无误。&lt;/p&gt;\n&lt;h3 id=\&#34;psh-推标志\&#34;&gt;PSH 推标志&lt;/h3&gt;\n&lt;p&gt;该标志置位时，接收端不将该&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE\&#34;&gt;数据&lt;/a&gt;进行队列处理，而是尽可能快将数据转由应用处理。在处理 &lt;a href=\&#34;https://baike.baidu.com/item/telnet\&#34;&gt;telnet&lt;/a&gt; 或 rlogin 等交互模式的连接时，该标志总是置位的。&lt;/p&gt;\n&lt;h3 id=\&#34;fin-结束标志\&#34;&gt;FIN 结束标志&lt;/h3&gt;\n&lt;p&gt;带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。&lt;/p&gt;\n&lt;h3 id=\&#34;urg-紧急标志\&#34;&gt;URG 紧急标志&lt;/h3&gt;\n&lt;p&gt;指镇优先（&lt;strong&gt;Urgent Pointer&lt;/strong&gt;）&lt;/p&gt;\n&lt;h3 id=\&#34;rst-复位标志\&#34;&gt;RST 复位标志&lt;/h3&gt;\n&lt;p&gt;用于复位相应的TCP连接。&lt;/p&gt;\n&lt;h2 id=\&#34;tcp-三次握手\&#34;&gt;TCP 三次握手&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukssf46mj30ed08gwei.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;blockquote&gt;\n&lt;p&gt;SYN ( Synchronize Sequence Numbers )：同步序列号，用于建立连接&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ACK ( Acknowledgement )：确认序列号有效&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;seq ( Sequence number )： 顺序号码&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;ack ( Acknowledge number )：确认号码&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。&lt;/li&gt;\n&lt;li&gt;第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/li&gt;\n&lt;li&gt;第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;为什么要三次握手\&#34;&gt;为什么要三次握手&lt;/h2&gt;\n&lt;p&gt;在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。&lt;/p&gt;\n&lt;p&gt;问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。&lt;/p&gt;\n&lt;p&gt;我们再来考虑，如果不是三次握手会出现什么情况呢：&lt;/p&gt;\n&lt;p&gt;假设有A和B两端要进行通信，&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;第一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信；&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如果是只有一次握手的话，这样肯定是不行的，A压根都不知道B是不是收到了这个请求。TCP协议变的与面向无连接的UDP 协议无异&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第二次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接；&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。也可能 B 收到的是 A 发送的失效了的报文（A发送后，由于某种原因没收到回应，报文被作废），B 建立了连接，A 却一直没有发送数据，占用着 B 的连接资源&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了；&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;第四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;tcp-四次挥手\&#34;&gt;TCP 四次挥手&lt;/h2&gt;\n&lt;p&gt;所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukuxutooj30e308zjrf.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。&lt;/li&gt;\n&lt;li&gt;第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。&lt;/li&gt;\n&lt;li&gt;第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。&lt;/li&gt;\n&lt;li&gt;第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;被动关闭具体流程：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0unpy9lz2j30dz05b0sp.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;为什么要四次挥手\&#34;&gt;为什么要四次挥手&lt;/h2&gt;\n&lt;p&gt;本质的原因是tcp是全双工的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。&lt;/p&gt;\n&lt;p&gt;因为TCP有个半关闭状态，假设A.B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。&lt;/p&gt;\n&lt;p&gt;在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是&lt;strong&gt;全双工模式&lt;/strong&gt;，&lt;strong&gt;接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;四次挥手牵扯到的状态装换：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;**FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；&lt;/p&gt;\n&lt;p&gt;**FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；&lt;/p&gt;\n&lt;p&gt;**TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；&lt;/p&gt;\n&lt;p&gt;**CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；&lt;/p&gt;\n&lt;p&gt;**CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；&lt;/p&gt;\n&lt;p&gt;**LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；&lt;/p&gt;\n&lt;p&gt;**CLOSED ** 这个状态表示连接已经断开。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1g0uowyfpy6j30k00mbq3x.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;参考\&#34;&gt;参考：&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/qq_34386891/article/details/80515912\&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.jianshu.com/p/e7f45779008a\&#34;&gt;简书&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/sdgihshdv/article/details/79503274\&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://blog.csdn.net/zzhongcy/article/details/38851271\&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;tcp-de-san-ci-wo-shou-he-si-ci-hui-shou&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;简述TCP的三次握手和四次挥手。一些个人的简单理&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;TCP的三次握手和四次挥手&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络&#34;,&#34;slug&#34;:&#34;74G4bblGm&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/74G4bblGm/&#34;}],&#34;date&#34;:&#34;2019-03-07 20:50:55&#34;,&#34;dateFormat&#34;:&#34;2019-03-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/tcp-de-san-ci-wo-shou-he-si-ci-hui-shou/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:548000,&#34;words&#34;:2564,&#34;minutes&#34;:10},&#34;description&#34;:&#34;前言\n\n简述TCP的三次握手和四次挥手。一些个人的简单理\n\n\nTCP 的六种标志位\nSYN 同步标志\n同步序列编号（Synchronize Sequence Numbers）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp-%E7%9A%84%E5%85%AD%E7%A7%8D%E6%A0%87%E5%BF%97%E4%BD%8D\&#34;&gt;TCP 的六种标志位&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#syn-%E5%90%8C%E6%AD%A5%E6%A0%87%E5%BF%97\&#34;&gt;SYN 同步标志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ack%E7%A1%AE%E8%AE%A4%E6%A0%87%E5%BF%97\&#34;&gt;ACK：确认标志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#psh-%E6%8E%A8%E6%A0%87%E5%BF%97\&#34;&gt;PSH 推标志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#fin-%E7%BB%93%E6%9D%9F%E6%A0%87%E5%BF%97\&#34;&gt;FIN 结束标志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#urg-%E7%B4%A7%E6%80%A5%E6%A0%87%E5%BF%97\&#34;&gt;URG 紧急标志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rst-%E5%A4%8D%E4%BD%8D%E6%A0%87%E5%BF%97\&#34;&gt;RST 复位标志&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;TCP 三次握手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;为什么要三次握手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;TCP 四次挥手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;为什么要四次挥手&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu 下安装及使用 Docker&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;docker\&#34;&gt;Docker&lt;/h2&gt;\n&lt;h3 id=\&#34;概念\&#34;&gt;概念&lt;/h3&gt;\n&lt;p&gt;Docker 是将发布程序运行所需要的环境打包到一起，自动化运行的容器；是一个开源项目，支持大部分的 Linux 发行版，操作系统层以上的虚拟化技术。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;\n&lt;h3 id=\&#34;优点\&#34;&gt;优点&lt;/h3&gt;\n&lt;p&gt;与传统的虚拟化方式相比：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;更高效的利用系统资源&lt;/li&gt;\n&lt;li&gt;更快的启动速度&lt;/li&gt;\n&lt;li&gt;一致的运行环境&lt;/li&gt;\n&lt;li&gt;持续交互和部署&lt;/li&gt;\n&lt;li&gt;更轻松的迁移&lt;/li&gt;\n&lt;li&gt;更轻松的维护和扩展&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;组成\&#34;&gt;组成&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Docker Client：通过 Api 访问 Docker Daemon 管理 Docker 镜像&lt;/li&gt;\n&lt;li&gt;Docker Daemon：守护进程，负责 Docker 镜像的创建、删除、启动、停止等服务&lt;/li&gt;\n&lt;li&gt;Docker Image：镜像，一张 “只读” 的系统 CD&lt;/li&gt;\n&lt;li&gt;Docker Container：Docker 的容器，Docker Images 运行实例&lt;/li&gt;\n&lt;li&gt;Docker Registry：Docker Images 的仓库，Docker Hub：https://www.dockerhub.com&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;ubuntu-安装-docker\&#34;&gt;Ubuntu 安装 Docker&lt;/h2&gt;\n&lt;p&gt;参考：&lt;a href=\&#34;https://www.jianshu.com/p/07e405c01880\&#34;&gt;简书&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;方式一\&#34;&gt;方式一&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;使用官方脚本自动安装&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;方式二\&#34;&gt;方式二&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;添加HTTPS协议，允许apt从HTTPS安装软件包&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo apt-get install  apt-transport-https  ca-certificates curl  software-properties-common\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;添加 Docker 公共密钥&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# docker 官方源\ncurl -fsSL  https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add\n\n# docker 中科大源，添加中科大即可\ncurl -fsSL  https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;设置版本库类型（Ubuntu18.04对应版本**“bionic“”**），软件版本包括三种：stable、edge、test&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# Docker 官方\nsudo add-apt-repository &amp;quot;deb [arch=amd64]  https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;quot; \n\n\n# Docker 中科大\nsudo add-apt-repository &amp;quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;quot; \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;安装 Docker CE&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 更新 apt-get 源\nsudo apt-get update\n\n# 安装\nsudo apt-get install docker-ce\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;docker-常用命令\&#34;&gt;Docker 常用命令&lt;/h2&gt;\n&lt;p&gt;参考：&lt;a href=\&#34;https://blog.csdn.net/hcljava/article/details/78588623\&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;添加用户到-docker-用户组\&#34;&gt;添加用户到 docker 用户组&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;创建 docker 用户组&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo groupadd docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;把需要的用户加入 docker 用户组&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo usermod -aG docker ${USER}\n\nsudo gpasswd -a dylan docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;重启 docker 服务&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo systemctl restart docker\n\nsudo service docker restart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;切换用户后重新登录此普通用户，才能生效&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;docker-基本\&#34;&gt;Docker 基本&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;启动 docker&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;systemctl start docker\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看 docker 版本&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 简单查看版本\ndocker -v  [--version]\n\n# 查看详细版本\ndocker version\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;显示 docker 系统的信息&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker info\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;操纵-docker-镜像\&#34;&gt;操纵 Docker 镜像&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;检索 image&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker search image-name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;下载 image&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker pull image-name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;列出镜像列表&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker images\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除一个或多个 images 镜像（删除时需要先删除容器，使用 &lt;code&gt;docker ps -a&lt;/code&gt; 查看运行的容器，使用 &lt;code&gt;docker rm 容器id&lt;/code&gt; 删除容器） ——参考：&lt;a href=\&#34;https://blog.csdn.net/flydreamzhll/article/details/80900509\&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker rmi image-name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;显示一个镜像的历史&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker history image-name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;通过容器创建镜像&lt;/p&gt;\n&lt;p&gt;从已经创建的容器中更新镜像，并且提交这个镜像 *使用 Dockerfile 指令来创建一个新的镜像 下面通过已存在的容器创建一个新的镜像&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker commit -m=&amp;quot;First Image&amp;quot; -a=&amp;quot;keke&amp;quot; 7a15f99695c0 keke/unbantu:17.10.0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参数说明：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;-m  提交的描述信息\n-a  指定镜像作者\n7a15f99695c0 记住这个是容器id，不是镜像id\nkeke/unbantu:17.10.0 创建的目标镜像名\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;镜像发布&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;在&lt;a href=\&#34;https://www.docker.com/\&#34;&gt;Docker&lt;/a&gt; 注册账户，发布的镜像都在&lt;a href=\&#34;https://cloud.docker.com/repository/list\&#34;&gt;这个页面里&lt;/a&gt;展示&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;将上面做的镜像unbantu，起个新的名字unbantu-test&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker tag keke/unbantu:17.10.0 keke/unbantu-test:lastest\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;登录 docker&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker login\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;上传 Ubuntu 镜像&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker push keke/unbantu-test:lastest\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;启动容器\&#34;&gt;启动容器&lt;/h3&gt;\n&lt;p&gt;Docker 容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;在容器中安装新的程序&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker run image-name apt-get install -y -name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意：在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在容器中运行库 echo 命令&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker run image-name echo &amp;quot;hello word&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;交互式进入容器中&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker run -i -t image_name /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;查看容器\&#34;&gt;查看容器&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;列出当前所有正在运行的 container&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker ps\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;列出所有的 container&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker ps -a\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;列出最近一次启动的 container&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker ps -l\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;操纵容器\&#34;&gt;操纵容器&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;保存对容器的修改&lt;/p&gt;\n&lt;p&gt;当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker commit ID new-image-name\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;选项：&lt;code&gt;-a, --author=&amp;quot;&amp;quot; Author; -m, --message=&amp;quot;&amp;quot; Commit message&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除所有容器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker rm `docker ps -a -q`\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除单个容器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker rm Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;-f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;停止、启动、杀死一个容器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker stop Name/ID  \n\ndocker start Name/ID  \n\ndocker kill Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;从一个容器中取出日志&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker logs Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;-f, --follow=false Follow log output; -t, --timestamps=false Show timestamps&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker diff Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;显示一个运行的容器里面的进程信息&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker top Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;从容器里面拷贝文件/目录到本地一个路径&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker cp Name:/container-path to-path  \n\ndocker cp ID:/container-path to-path\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;.重启一个正在运行的容器&lt;/p&gt;\n&lt;p&gt;-t, --time=10 Number of seconds to try to stop for before killing the container, Default=10&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker restart Name/ID\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在容器外，使用容器执行命令&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker exec 容器名 命令\n\ndocker exec -i -t  mynginx /bin/bash\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;附加到一个运行的容器上面&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker attach ID #重新启动并运行一个交互式会话shell\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构建镜像\&#34;&gt;构建镜像&lt;/h3&gt;\n&lt;h4 id=\&#34;一-通过-commit-命令提交容器为镜像\&#34;&gt;一、通过 commit 命令提交容器为镜像&lt;/h4&gt;\n&lt;p&gt;在容器中设置好我们所需要的配置，使用 &lt;code&gt;docker commit&lt;/code&gt; 来提交容器作为镜像&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker commit -m=&amp;quot;A new custom image&amp;quot; --author=&amp;quot;Bourbon Tian&amp;quot; b437ffe4d630 test/apache2:webserver\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;选项：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; ：用来指定创建镜像要提交的消息&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;--author&lt;/code&gt; ：用来列出该镜像的作者信息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;二-通过-dockerfile-文件构建镜像\&#34;&gt;二、通过 Dockerfile 文件构建镜像&lt;/h4&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;创建文件夹并在其中创建 Dockerfile 文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;在 Dockerfile 中写入镜像 有关指令&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;运行 &lt;code&gt;docker build&lt;/code&gt; 构建镜像&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker build -t dylan/ubuntu:v1 . \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;选项：&lt;code&gt;-t&lt;/code&gt; ：tag 、&lt;code&gt;-f&lt;/code&gt;：dockerfile 文件位置&lt;/p&gt;\n&lt;p&gt;​&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;保存和加载镜像\&#34;&gt;保存和加载镜像&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;保存镜像到一个 tar 包； -o --output=&amp;quot;&amp;quot; Write to an file&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker save image-name -o file-path\n\n# Ubuntu 上保存nginx 到 tmp 下\ndocker save nginx:latest &amp;gt; /tmp/nginx.tar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;加载一个tar包格式的镜像; -i, --input=&amp;quot;&amp;quot; Read from a tar archive file&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker load -i file-path\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;从 A 机器拷贝到 B 机器&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;docker load &amp;lt; /home/keke/main.tar\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-docker&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu 下安装及使用 Docker&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu安装及使用Docker&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Docker&#34;,&#34;slug&#34;:&#34;hOA1U8UfK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/hOA1U8UfK/&#34;},{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2019-03-01 15:06:59&#34;,&#34;dateFormat&#34;:&#34;2019-03-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/ubuntu-docker/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:448000,&#34;words&#34;:1761,&#34;minutes&#34;:8},&#34;description&#34;:&#34;前言\n\nUbuntu 下安装及使用 Docker\n\n\nDocker\n概念\nDocker 是将发布程序运行所需要的环境打包到一起，自动化运行的容器；是一个开源项目，支持大部分的 Linux 发行版，操作系统层以上的虚拟化技术。容器是完全使用沙...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker\&#34;&gt;Docker&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5\&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E7%82%B9\&#34;&gt;优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%84%E6%88%90\&#34;&gt;组成&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu-%E5%AE%89%E8%A3%85-docker\&#34;&gt;Ubuntu 安装 Docker&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%B8%80\&#34;&gt;方式一&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%BA%8C\&#34;&gt;方式二&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\&#34;&gt;Docker 常用命令&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0-docker-%E7%94%A8%E6%88%B7%E7%BB%84\&#34;&gt;添加用户到 docker 用户组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker-%E5%9F%BA%E6%9C%AC\&#34;&gt;Docker 基本&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E7%BA%B5-docker-%E9%95%9C%E5%83%8F\&#34;&gt;操纵 Docker 镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8\&#34;&gt;启动容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8\&#34;&gt;查看容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E7%BA%B5%E5%AE%B9%E5%99%A8\&#34;&gt;操纵容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\&#34;&gt;构建镜像&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E9%80%9A%E8%BF%87-commit-%E5%91%BD%E4%BB%A4%E6%8F%90%E4%BA%A4%E5%AE%B9%E5%99%A8%E4%B8%BA%E9%95%9C%E5%83%8F\&#34;&gt;一、通过 commit 命令提交容器为镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E9%80%9A%E8%BF%87-dockerfile-%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\&#34;&gt;二、通过 Dockerfile 文件构建镜像&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD%E9%95%9C%E5%83%8F\&#34;&gt;保存和加载镜像&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu安装MySql&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;ubuntu-安装-mysql\&#34;&gt;Ubuntu 安装 MySQL&lt;/h1&gt;\n&lt;h2 id=\&#34;安装\&#34;&gt;安装&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;修改 apt 源（已修改的可忽略）&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;备份原文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编辑源列表文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo vim /etc/apt/sources.list\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除原来的文件内容，添加下列源&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-list\&#34;&gt;deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;更新 apt-get 数据源&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo apt-get update\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;使用 apt-get 安装 &lt;code&gt;mysql-server&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;apt-get install mysql-server\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;配置\&#34;&gt;配置&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;运行安全脚本&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysql_secure_installation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看 MySQL 状态&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;systemctl status mysql.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看 MySQL 版本&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;mysqladmin -p -u root version\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;配置远程访问&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 修改配置文件\nvim /etc/mysql/mysql.conf.d/mysqld.cnf\n\n# 注释掉绑定的 IP地址\nbind-address = 127.0.0.1\n\n# 重启 MySQL\nservice mysql restart\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;登录 MySQL，并在其中操作&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-mysql\&#34;&gt;-- 登录\nmysql -u root -p\n\n-- 设置密码安全策略\nset global validate_password_policy=0;\n-- 设置密码最少长度\nset global validate_password_length=1;\n\n-- 允许root用户/密码“123456”,在localhost发起的访问\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;\n-- 允许root用户/密码“123456”,在127.0.0.1发起的访问\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;127.0.0.1&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;\n-- 允许root用户/密码“123456”,在局域网所以ip发起的访问\nGRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;\n\n-- 刷新权限\nFLUSH PRIVILEGES;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改 &lt;code&gt;mysqld.cnf&lt;/code&gt; 配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 进入文件\nvi /etc/mysql/mysql.conf.d/mysqld.cnf\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在 &lt;code&gt;[mysqld]&lt;/code&gt; 节点上增加一个节点&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;[client]\ndefault-character-set=utf8\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在 &lt;code&gt;[mysqld]&lt;/code&gt; 节点底部增加如下配置&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;skip-grant-tables\ndefault-storage-engine=INNODB\ncharacter-set-server=utf8\ncollation-server=utf8_general_ci\nlower-case-table-names = 1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;​\t注：出现拒绝访问root用户的解决方案，添加上述 &lt;code&gt;skip-grant-tables&lt;/code&gt; 配置&lt;/p&gt;\n&lt;p&gt;​      参考：&lt;a href=\&#34;https://blog.csdn.net/qq_36675754/article/details/81381341\&#34;&gt;CSDN&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;​      配置文件详情：&lt;a href=\&#34;https://blog.csdn.net/lienfeng6/article/details/78140404\&#34;&gt;mysql配置文件详情&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;常用命令\&#34;&gt;常用命令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;启动&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 启动方式1 \nservice mysql start\n\n# 启动方式2\nsystemctl start mysql.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;停止&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;service mysql stop\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;重启&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;service mysql restart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看 MySQL 状态&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;systemctl status mysql.service\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;部署应用到生产环境\&#34;&gt;部署应用到生产环境&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;导入数据库&lt;/p&gt;\n&lt;p&gt;使用 MySQL 工具导入即可&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;设置 Tomcat 远程访问密码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;1. 修改 Tomcat 下的 conf/tomcat-users.xml\n&amp;lt;tomcat-users&amp;gt; \n&amp;lt;role rolename=&amp;quot;manager-gui&amp;quot;/&amp;gt; \n&amp;lt;role rolename=&amp;quot;admin-gui&amp;quot;/&amp;gt; \n&amp;lt;role rolename=&amp;quot;manager-script&amp;quot;/&amp;gt; \n&amp;lt;user username=&amp;quot;admin&amp;quot; password=&amp;quot;admin&amp;quot; roles=&amp;quot;manager-gui,admin-gui,manager-script&amp;quot;/&amp;gt; \n&amp;lt;/tomcat-users&amp;gt; \n\n2. 同时还需要修改，如无新建conf/Catalina/localhost/manager.xml 内容如下：\n\n&amp;lt;Context privileged=&amp;quot;true&amp;quot; antiResourceLocking=&amp;quot;false&amp;quot;\n         docBase=&amp;quot;${catalina.home}/webapps/manager&amp;quot;&amp;gt;\n    &amp;lt;Valve className=&amp;quot;org.apache.catalina.valves.RemoteAddrValve&amp;quot; allow=&amp;quot;^.*$&amp;quot; /&amp;gt;\n&amp;lt;/Context&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;部署 WEB 项目&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;手动发布&lt;/p&gt;\n&lt;p&gt;访问地址：&lt;code&gt;http://10.3.133.33:8080/manager&lt;/code&gt; 页面，利用 Tomcat 进行发布&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Maven 插件发布&lt;/p&gt;\n&lt;p&gt;在项目最顶层添加插件，运行插件即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt; &amp;lt;build&amp;gt;\n        &amp;lt;plugins&amp;gt;\n            &amp;lt;!-- tomcat插件 --&amp;gt;\n            &amp;lt;plugin&amp;gt;\n                &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;\n                &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;\n                &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;\n                &amp;lt;configuration&amp;gt;\n                    &amp;lt;url&amp;gt;http://10.3.50.119:8080/manager/text&amp;lt;/url&amp;gt;\n                    &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;\n                    &amp;lt;password&amp;gt;admin&amp;lt;/password&amp;gt;\n                    &amp;lt;update&amp;gt;true&amp;lt;/update&amp;gt;\n                    &amp;lt;path&amp;gt;/test&amp;lt;/path&amp;gt;\n                &amp;lt;/configuration&amp;gt;\n            &amp;lt;/plugin&amp;gt;\n        &amp;lt;/plugins&amp;gt;\n    &amp;lt;/build&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-mysql&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu安装MySql&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu安装MySql&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;MySql&#34;,&#34;slug&#34;:&#34;13DspYgf6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/13DspYgf6/&#34;},{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2019-02-28 19:54:51&#34;,&#34;dateFormat&#34;:&#34;2019-02-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/ubuntu-mysql/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:285000,&#34;words&#34;:954,&#34;minutes&#34;:5},&#34;description&#34;:&#34;前言\n\nUbuntu安装MySql\n\n\nUbuntu 安装 MySQL\n安装\n\n\n修改 apt 源（已修改的可忽略）\n\n\n备份原文件\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.b...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu-%E5%AE%89%E8%A3%85-mysql\&#34;&gt;Ubuntu 安装 MySQL&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85\&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\&#34;&gt;常用命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E5%88%B0%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83\&#34;&gt;部署应用到生产环境&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu 安装 Tomcat&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;ubuntu-安装-tomct\&#34;&gt;Ubuntu 安装 Tomct&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;官网下载 Linux 对应的安装包&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;http://tomcat.apache.org/download-80.cgi\&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;上传并解压缩，移动到 &lt;code&gt;/usr/local/tomcat8&lt;/code&gt;，设置所有者&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 解压\ntar -zxvf apache-tomcat-8.5.23.tar.gz\n# 重命名\nmv apache-tomcat-8.5.23 tomcat\n# 移动目录\nmv tomcat /usr/local/tomcat8/\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Tomcat常用命令&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 启动\n/usr/local/tomcat/bin/startup.sh\n\n# 停止\n/usr/local/tomcat/bin/shutdown.sh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-tomcat&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu 安装 Tomcat&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu安装Tomcat&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;GMzyxFnFy&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/GMzyxFnFy/&#34;}],&#34;date&#34;:&#34;2019-02-28 19:54:43&#34;,&#34;dateFormat&#34;:&#34;2019-02-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/ubuntu-tomcat/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:25000,&#34;words&#34;:91,&#34;minutes&#34;:1},&#34;description&#34;:&#34;前言\n\nUbuntu 安装 Tomcat\n\n\nUbuntu 安装 Tomct\n\n\n官网下载 Linux 对应的安装包\n\n官网\n\n\n\n上传并解压缩，移动到 /usr/local/tomcat8，设置所有者\n# 解压\ntar -zxvf apa...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu-%E5%AE%89%E8%A3%85-tomct\&#34;&gt;Ubuntu 安装 Tomct&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu系统对网卡设置静态地址和设置时区&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;ubuntu设置网卡静态地址\&#34;&gt;Ubuntu设置网卡静态地址&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;进入网卡配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;vim /etc/netplan/50-cloud-init.yaml\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改\u001d配置如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;network:\n    ethernets:\n        enp0s3:\n            addresses: [10.3.133.33/24]\n            gateway4: 10.3.133.1\n            dhcp4: no\n            dhcp6: no\n            nameservers:\n                addresses: [10.3.133.1,114.114.114.114]\n    version: 2         \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;使配置生效&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;netplan apply\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;ubuntu设置时区\&#34;&gt;Ubuntu设置时区&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;运行如下命令选择时区&lt;br&gt;\n亚洲 -&amp;gt; 中国 -&amp;gt; 北京&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo tzselect\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建时区软连接&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;ubuntu-设置-ssh-可通过-root-用户登录\&#34;&gt;Ubuntu 设置 ssh 可通过 Root 用户登录&lt;/h2&gt;\n&lt;p&gt;当我们使用远程连接工具通过 root 用户登录 Ubuntu 时，会出现 &lt;code&gt;Permission denied,please try again&lt;/code&gt; 并一直让我们输入密码，出现这中情况，是因为我们系统默认禁止 root 用户 ssh 登录。解决办法如下&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;参考：&lt;a href=\&#34;https://blog.csdn.net/u010867294/article/details/78109551\&#34;&gt;CSDN&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;普通用户登录，并切换为 root 用户&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;更改 &lt;code&gt;sshd_config&lt;/code&gt; 文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;vim /etc/ssh/sshd_config\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;找到 **#Authentication:**下的 &lt;code&gt;PermitRootLogin without-password&lt;/code&gt; 如果是没注释的则注释掉。并在下面加上一行&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;PermitRootLogin yes\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;找错 &lt;strong&gt;Authentication&lt;/strong&gt;下的 &lt;code&gt;PasswordAuthentication&lt;/code&gt; 开启密码验证&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# Authentication:\n PasswordAuthentication yes //默认为no，改为yes开启密码登陆\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;重启 ssh 服务，使配置生效&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;/etc/init.d/ssh restart\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-bi-yao-she-zhi&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Ubuntu系统对网卡设置静态地址和设置时区&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu必要设置&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2019-02-28 16:54:47&#34;,&#34;dateFormat&#34;:&#34;2019-02-28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/ubuntu-bi-yao-she-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:77000,&#34;words&#34;:304,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\n\nUbuntu系统对网卡设置静态地址和设置时区\n\n\nUbuntu设置网卡静态地址\n\n\n进入网卡配置文件\nvim /etc/netplan/50-cloud-init.yaml\n\n\n\n修改\u001d配置如下\nnetwork:\n    ether...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1%E9%9D%99%E6%80%81%E5%9C%B0%E5%9D%80\&#34;&gt;Ubuntu设置网卡静态地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA\&#34;&gt;Ubuntu设置时区&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu-%E8%AE%BE%E7%BD%AE-ssh-%E5%8F%AF%E9%80%9A%E8%BF%87-root-%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95\&#34;&gt;Ubuntu 设置 ssh 可通过 Root 用户登录&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;轻尘的博客，记录工作，记录生活&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:6000,&#34;words&#34;:32,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n轻尘的博客，记录工作，记录生活\n&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;hr&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://static.chiphell.com/forum/201808/06/191741r919cyy9n55b7ppg.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;nas&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;软路由的CPU&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;NAS&#34;,&#34;slug&#34;:&#34;OS0B8NA5p&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/OS0B8NA5p/&#34;},{&#34;name&#34;:&#34;软路由&#34;,&#34;slug&#34;:&#34;aJQuqu3CZ6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/aJQuqu3CZ6/&#34;}],&#34;date&#34;:&#34;2018-09-19 21:49:16&#34;,&#34;dateFormat&#34;:&#34;2018-09-19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/nas/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:7000,&#34;words&#34;:35,&#34;minutes&#34;:1},&#34;description&#34;:&#34;前言\n\n今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。\n\n\n\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;运维常用命令\&#34;&gt;运维常用命令&lt;/h2&gt;\n&lt;!-- more --&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Linux命令详解：&lt;code&gt;man.linuxde.net/命令名&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;ifconfig&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;查看网络地址：&lt;code&gt;# ifconfig&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;网卡配置文件：&lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;网卡配置详细内容&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;DEVICE=eth0 网卡的名字\n\nHWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址\n\nTYPE=Ethernet 网络类型 以太网\n\nUUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。\n\nONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡\n\nNM_CONTROLLED=yes 是否受network程序管理\n\nBOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式\n\n　　a. dhcp 自动获取ip地址\n\n　　b. none 固定的ip地址\n\n　　c. static 固定的ip地址\n\nIPADDR=10.0.0.100 IPADDR ip地址\n\nNETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器\n\nGATEWAY=10.0.0.2 网关 整个大楼的大门\n\nUSERCTL=no 普通用户是否能控制网卡\n\n/etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf\n\nDNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;重启网卡：&lt;code&gt;# /etc/init.d/network restart&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;nameserver&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;配置DNS服务器：&lt;code&gt;# nameserver 8.8.8.8&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;du&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;显示文件的大小：&lt;code&gt;# du -h 文件路径&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;-h：以易读的方式显示&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;ps -ef&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;当前系统的进程状态：&lt;code&gt;# ps -ef&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;选项&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;-e：显示所有程序，与‘A’效果相同\n-f：显示UID,PPIP,C与STIME栏位。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;搭配 &lt;code&gt;grep&lt;/code&gt; 可以过滤所需要查看的进程：&lt;code&gt;# ps -ef | grep vim&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;搭配 &lt;code&gt;kill&lt;/code&gt; 可结束进程：&lt;code&gt;kill PID/进程名&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;top&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;实时查看系统的运行情况：&lt;code&gt;# top&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可按c、m等键按照CPU、Memory排序&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;按q退出&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;df -th&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;显示磁盘分区上可使用的磁盘空间：&lt;code&gt;# df -th&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;选项&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;-t (--type)仅显示指定文件系统类型的磁盘信息\n-h 以可读性较高的方式显示\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;mount&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;加载文件系统到指定的加载点：&lt;code&gt;# mount /dev/cdrom /mnt/cdrom&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt; 目录下存放了外部设备&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt; 目录下可用于挂载外部设备&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;tar&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;归档，压缩，解压缩等&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;选项：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;-x    解压缩文件\n-c    创建压缩文件(create)\n-z\t  gzip\n-j\t  bzip2\n-v\t  显示过程\n-t    查看压缩包内文件\n-f    (file)必备选项\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看&lt;code&gt;.tar.gz&lt;/code&gt;文件：&lt;code&gt;# tar -ztvf log.tar.gz&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;解压&lt;code&gt;.tar.gz&lt;/code&gt;文件：&lt;code&gt;# tar -zxvf /opt/soft/test/log.tar.gz&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;将文件打包：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# tar -cvf log.tar log2012.log       仅打包，不压缩，最后一列是操作对象，也即是要打包的文件\n# tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 \n# tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;rpm&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;从rpm软件包安装软件：&lt;code&gt;# rpm -ivh 软件包路径&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;列出所安装的rpm软件：&lt;code&gt;# rpm -qa&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;一个rpm包中的文件安装到那里去了：&lt;code&gt;rpm -ql rpm包名&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;ntp-时间服务器的配置\&#34;&gt;NTP 时间服务器的配置&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;可参考：&lt;a href=\&#34;https://www.cnblogs.com/jczhu/p/5851268.html\&#34;&gt;火之晨曦&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;安装NTP服务&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# yum install ntp ntpdate\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# vim /etc/ntp.conf\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;把下列配置替换原有配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;driftfile /var/lib/ntp/drift\nrestrict default kod nomodify notrap nopeer noquery\nrestrict -6 default kod nomodify notrap nopeer noquery\nrestrict 127.0.0.1\nrestrict -6 ::1\nserver 127.127.1.0\t\t#local clock\nserver pool.ntp.org\t\t#local clock\nfudge 127.127.1.0 stratum 10\nincludefile /etc/ntp/crypto/pw\nkeys /etc/ntp/keys\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看NTP服务器&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# ntpq -p\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;dhcp-服务器\&#34;&gt;DHCP 服务器&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;可参考：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;安装DHCP服务&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;# yum install dhcp dhcp-devel -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改配置文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# vim /etc/dhcp.conf\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;配置：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;samba-服务器\&#34;&gt;Samba 服务器&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;可参考：&lt;a href=\&#34;https://www.cnblogs.com/hxgoto/p/7071175.html\&#34;&gt;一如莱戈、&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;安装samba服务&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# yum install -y samba\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;安装成功后，系统会生成服务的配置文件和一些命令工具&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;/etc/samba/smb.conf&lt;/code&gt;  //是samba服务的主配置文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;/etc/init.d/smb&lt;/code&gt;             //是samba的启动/关闭文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看开机启动情况：&lt;code&gt;# service smb status&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;启动服务：&lt;code&gt;# service smb start&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;设置开机启动：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# chkconfig  --level 35 smb on      // 设置开机启动\n# chkconfig --list smb\t\t\t\t、、 查看0-6的状态，smb服务启动或关闭\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;\n&lt;p&gt;配置&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# vim /etc/samba/smb.conf\n\n配置：\n\n[global]　　　　　　　　　　　　　　//设置samba服务整体环境\n\nworkgroup = WORKGROUP　　　　　  //设置工作组名称\nserver string = Samba Server Version %v     //服务器说明\n\n[dingLinux]　　　　　　　//共享目录的名称\n\ncomment = Public stuff　　　//注释说明　\npath = /usr/local/laig　　　//共享目录的路径\npublic = yes　　　 　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)\nwriteable = yes　　　　　//是yes/否no不以只读方式共享当与read only发生冲突时，无视read only\nbrowseable = yes　      //是yes/否no在浏览资源中显示共享目录，若为否则必须指定共享路径才能存取\nguest ok = yes　　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;注意&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;防火墙要关闭： &lt;code&gt;# service iptables stop&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;selinux要设置成disabled，路径是：&lt;code&gt;/etc/sysconfig/selinux&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;注意共享目录的权限设置&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;要设置成不需要用户名密码直接访问，需要修改配置文件，将&lt;code&gt;security&lt;/code&gt;设置成&lt;code&gt;security = share&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改配置后要重启服务：&lt;code&gt;# service smb restart&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;访问共享文件夹&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;在windows中打开文件资源管理器输入 &lt;code&gt;\\\\192.168.1.194&lt;/code&gt; 进行访问，ip地址根据自己的服务器地址来输入&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;apache服务器安装\&#34;&gt;Apache服务器安装&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;yun-wei-bi-ji&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;运维常用命令\&#34;&gt;运维常用命令&lt;/h2&gt;\n&#34;,&#34;title&#34;:&#34;运维笔记&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2018-08-31 13:01:01&#34;,&#34;dateFormat&#34;:&#34;2018-08-31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/yun-wei-bi-ji/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:323000,&#34;words&#34;:1280,&#34;minutes&#34;:6},&#34;description&#34;:&#34;运维常用命令\n\n\n\nLinux命令详解：man.linuxde.net/命令名\n\n\nifconfig\n\n\n查看网络地址：# ifconfig\n\n\n网卡配置文件：/etc/sysconfig/network-scripts/ifcfg-eth...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E7%BB%B4%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\&#34;&gt;运维常用命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ntp-%E6%97%B6%E9%97%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE\&#34;&gt;NTP 时间服务器的配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dhcp-%E6%9C%8D%E5%8A%A1%E5%99%A8\&#34;&gt;DHCP 服务器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#samba-%E6%9C%8D%E5%8A%A1%E5%99%A8\&#34;&gt;Samba 服务器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#apache%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85\&#34;&gt;Apache服务器安装&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;系统引导修复\&#34;&gt;系统引导修复&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;进入PE系统&lt;/li&gt;\n&lt;li&gt;新建一个分区，系统模式为ESP&lt;/li&gt;\n&lt;li&gt;记住ESP分区对应的盘符，未分配盘符的话可 用工具进行挂载&lt;/li&gt;\n&lt;li&gt;系统命令模式下，输入下列命令&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    bcdboot c:\\windows /s z: /f UEFI /l zh-cn\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;查看引导文件是否建立成功&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;xi-tong-yin-dao-xiu-fu&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;p&gt;这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;系统引导修复&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Windows&#34;,&#34;slug&#34;:&#34;tha1vsQld&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/tha1vsQld/&#34;}],&#34;date&#34;:&#34;2018-08-04 19:41:44&#34;,&#34;dateFormat&#34;:&#34;2018-08-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/xi-tong-yin-dao-xiu-fu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:24000,&#34;words&#34;:111,&#34;minutes&#34;:1},&#34;description&#34;:&#34;前言\n这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法\n\n系统引导修复\n\n进入PE系统\n新建一个分区，系统模式为ESP\n记住ESP分区对应的盘符，未分配盘符的话可 用工具进行挂载\n系统命令模式下，输入下列命令    b...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D\&#34;&gt;系统引导修复&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;整理巩固一下Linux的知识&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;简介\&#34;&gt;简介&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;特点：多用户多任务、良好的兼容性、可移植性强、稳定性高、界面美观&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;版本：X.Y.Z  主版本号、次版本号(偶数是正式版本，奇数是测试版本不稳定)、修改次数&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;系统结构&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;Linux系统结构&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;应用程序&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;应用程序                     X  Window&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;Shell层&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;内核&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;ol&gt;\n&lt;li&gt;Shell层：用户与内核之间的桥梁。&lt;/li&gt;\n&lt;li&gt;内核：操作系统的核心，管理着整个计算机的软硬件资源。&lt;/li&gt;\n&lt;li&gt;分区：至少要有两个分区  swap分区和 根分区。&lt;/li&gt;\n&lt;li&gt;文件管理：ext4文件系统&lt;/li&gt;\n&lt;li&gt;设备管理：\n&lt;ul&gt;\n&lt;li&gt;字符设备：以字符为单位进行输入输出，CPU能直接进行读写。      打印机，扫描仪，声卡、显卡、鼠标、键盘等&lt;/li&gt;\n&lt;li&gt;块设备：以数据块为单位进行输入输出，CPU不能直接进行读写，要经过缓冲区。    硬盘、光盘、U盘&lt;/li&gt;\n&lt;li&gt;网络设备：以数据包进行数据交换。网卡&lt;/li&gt;\n&lt;li&gt;注：无论是哪类设备，Linux都统一当做文件来处理&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;命令\&#34;&gt;命令&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;命令提示符\n    [root@centos  ~]#\n    [ding@centos  ~]$\n  用户名、主机名、目录名、提示符\n\n命令格式\n    命令名 [选项] [参数]\n\n\n注销  exit    Ctrl+D\n重启  reboot   shutdown -r now    注：-r的选项是reboot\n关机  halt     shutdown -h now    注：-h的选项是halt \n\n查看时间：date\n修改时间：date 184512302017     点数 月份 年\n显示日历：cal  可加参数 [年份],查看全年日历\n\npwd 显示当前目绝对路径\n\ncd 切换目录\n\nls  -l  显示详细信息(文件类型、权限、所有者、组群、文件大小、修改时间、文件名)\n    -a  显示所有文件和目录\n\ncat   显示文本文件内容\n    -n 在内容前显示行号\n\nmore/less 文件   分屏显示文件(文件过长时，一屏幕一屏幕的显示)\n            按空格 显示下一屏， 按回车 显示下一行， 按q 退出more命令\n\ntail [选项] 文件    显示文本结尾部分\n     -n 10 文件名  显示文件的倒数10行\nhead命令与tail相同\n\nman 命令名    显示命令的手册页帮助信息，按q退出man   命令不懂找男人\n命令名 --help  显示命令的帮助信息(非所有命令都有此选项)   \n\nclear   清屏\n\nwc [选项] 文件     按顺序显示： 行数 单词数 字符数 文件名\n    -c    显示文件的字符数    char\n    -l    显示文件的行数      low\n    -w    显示文件的单词数    word\n\n&amp;gt; 输出重定向   &amp;lt; 输入重定向   &amp;gt;&amp;gt; 附加输出重定向     错误重定向：结果显示在屏幕上，错误信息重定向到指定文件用  2&amp;gt;\n                                                            结果和错误信息都重定向到指定文件用  &amp;amp;&amp;gt;\n\n创建f1文件： cat &amp;gt;f1    进入输入界面，到文本的下一行按 Ctrl+D 结束输入\n\n附加输出重定向：   cat &amp;gt;&amp;gt;f1  在f1后追加内容\n\n管道  |  前一个命令的执行结果是后一个命令的执行条件   ls  | wc -l    统计当前目录下的文件和目录总数\n\nhistory 5  查看最近执行的 5条命令 命令上限1000\n!! 命令 再次执行上一条命令，!5 执行history中 5 对应的命令\n\n别名：alias vi=&#39;vim&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;vim编辑器\&#34;&gt;vim编辑器&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;命令模式：刚进入vi时的模式\n文本模式：i\n最后行模式：按 [shift和冒号] 进入\n\n输入文本   [命令模式下]\n    i/I  a/A  o/O\n\n查找字符串  [命令模式下]\n    /字符串    从头往下找，找到则停在字符串首字母上\n    ？字符串   从当前位置往下找，找到停在字符串首字母上\n       n      继续查找满足条件的字符串\n       N      改变查找方向，继续查找满足条件的字符串\n\n撤销与重复   [命令模式下]\n    u  撤销上一步操作\n    .  重复上一步操作\n\n文本块操作\n    set nu       显示行号\n    set nonu     不显示行号\n    n1,n2 co n3  将 [n1,n2]行，复制到n3行之下\n    n1,n2 m n3   将 [n1,n2]行，移动到n3行之下\n    n1,n2 d      删除 [n1,n2]行\n    n1,n2 s/字符串1/字符串2/g      将[n1,n2]行中所有的 [字符串1] 用 [字符串2] 替换\n\n保存与退出\n    [命令模式下] 连续按两次 z 保存并退出\n    \n    [最后行模式下]\n        :w 文件  保存为指定的文件\n        :q       退出，若文件有改动则提示\n        :q!      不保存直接退出\n        :wq      存盘并退出\n        :x       存盘并退出\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;运行级别\&#34;&gt;运行级别&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;配置文件在  /etc/inittab  默认运行级别为 5&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;数字&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;模式&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;0&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;关机&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;单用户模式&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;2&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;多用户模式，不提供NFS&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;3&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;完整的多用户模式，仅提供&lt;code&gt;字符界面&lt;/code&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;4&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;保留的运行级别&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;5&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;完整的多用户模式，自动启动&lt;code&gt;图形化用户界面&lt;/code&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;6&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;重新启动&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;GNOME环境下：&lt;code&gt;Ctrl+Alt+[F2-F6]&lt;/code&gt; 回到字符界面&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;字符界面下：按&lt;code&gt;Alt+F1&lt;/code&gt; 回到 GNOME桌面&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;用户和群组\&#34;&gt;用户和群组&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;超级用户：UID 0        所属组群 GID 0\n系统用户  UID 1-499    所属组群 GID 1-499\n普通用户  UID 500-     所属组群 GID 500\n\n用户账号信息文件：/etc/passwd\n        文件内容：root:x:0:0:root:/root:/bin/bash\n            用户名 密码 UID GID 全名 主文件夹\n\n用户密码信息文件：/etc/shadow\n\n组群账号信息文件：/etc/group\n        文件内容：root:x:0:\n                 bin:x:1:bin,daemon     组群名 组群密码 组群管理员密码  以此组群为附加组群的用户列表\n\n组群密码信息文件：/etc/gshadow\n        文件内容：root:::                     加密密码字段为 !!\n                 bin:::bin,daemon     组群名 组群加密密码 组群管理员密码  以此组群为附加组群的用户列表\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt;  创建用户账号 超级用户才能使用&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    -c  全名\n    -d  主目录\n    -g  指定用户的主要组群\n    -G  指定用户的附加组群\n    -u  指定用户的UID\n    -M  只创建用户，不创建主目录\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt;     设置或修改密码 以及 密码属性&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    -d  删除用户密码\n    -l  锁定用户\n    -u  解除锁定\n    -S  显示指定用户账号的状态\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;usermod&lt;/code&gt; [选项]  用户名    修改用户属性 超级用户才能使用&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    -c 全名        指定用户的全称\n    -d 主目录      指定用户的主目录\n    -g                 指定用户的主要组群\n    -G 组群ID或组群名   指定用户的附加组群\n    -u 用户ID      指定用户的UID\n    -l 用户名      指定用户的新名称\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;userdel&lt;/code&gt;     删除用户账号 超级用户才能使用&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    -r  删除用户的账号和主目录，无此选项则保留主目录\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;su [-][用户名]&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    切换用户, `-` 选项表示切换到用户的主目录    \n    无用户名参数则切换到root用户\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;id [用户名]&lt;/code&gt; 查看用户的 UID、GID 和 用户所属组群&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;groupadd [选项] 组群名&lt;/code&gt;    新建组群，只有超级用户才能使用&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;     -g 组群id     指定组群的GID  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;groupmod&lt;/code&gt; [选项] 组群名    新建组群，只有超级用户才能使用&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;     -g 组群id     指定组群的GID \n     -n 组群名     指定组群的新名字   \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;groupdel&lt;/code&gt; 组群名   删除组群，只有root用户才能使用&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;批量创建多个用户\&#34;&gt;批量创建多个用户&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;创建 students 组群&lt;br&gt;\n&lt;code&gt;# groupadd -g 600 students&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建用户信息文件&lt;br&gt;\n使用文本编辑器编辑 /etc/passwd   编辑好后保存为students.txt&lt;br&gt;\nstudent1❌601:600::/home/student1:/bin/bash&lt;br&gt;\nstudent2❌602:600::/home/student2:/bin/bash&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建用户密码,保存为password.txt&lt;br&gt;\n```shell&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;     student1:123456\n     student2:123456\n ```\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;批量创建用户账号&lt;br&gt;\n&lt;code&gt;# newusers &amp;lt; students.txt&lt;/code&gt;&lt;br&gt;\n文件已经追加到 /etc/passwd ，系统已经在 /home 目录中为每位用户创建了主目录&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;暂时取消 shadow 加密&lt;br&gt;\n&lt;code&gt;# pwunconv&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;为用户设置密码&lt;br&gt;\n&lt;code&gt;# chpasswd &amp;lt; passwd.txt&lt;/code&gt;&lt;br&gt;\n密码追加到了/etc/shadow  在passwd文件内能看到密码&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;恢复 shadow 加密&lt;br&gt;\n&lt;code&gt;# pwconv&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;批量创建的用户，主目录中都缺少 &lt;code&gt;.bash_profile&lt;/code&gt; 和 &lt;code&gt;.bashrc&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;文件系统\&#34;&gt;文件系统&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;挂载：将存储介质的内容映射到指定的目录，此目录为该设备的挂载点。一个挂载的点一次只能挂载一个设备&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;`/etc/fstab`  保存着文件系统 开机自动挂载信息  \n`/etc/mtab `  保存着当前系统中 文件系统的挂载信息\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;文件分类：普通文件、目录文件、链接文件、设备文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;文件布局：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;目录&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;功能&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;/&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;Linux目录结构的起点&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;bin&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放可执行命令，如chmod、data&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;boot&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放系统启动时所需要的文件，包括内核和引导装载程序&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;dev&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放所有的设备文件，如cdrom光盘文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;etc&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放系统配置文件，如passwd、fstab&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;home&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;包含所有普通用户的主目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;lib&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;包含系统二进制文件所需要的共享库&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;lost+found&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放文件系统发生故障后无法归位的文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;media&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;移动存储戒指的默认挂载点&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;mnt&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;用于临时挂载文件系统&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;proc&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放进程的运行信息，由内核在内存中产生&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;root&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;超级用户的主目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;sbin&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放系统管理命令，一般只有超级用户才能使用&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;selinux&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放SELinux的相关文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;tmp&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放公用的临时文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;usr&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放应用程序及相关文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;vsr&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;存放系统中经常变化的文件，如系统日志文件，用户邮件等&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;文件扩展名&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;系统文件&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;后缀&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;文件&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.rpm&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;RPM软件包文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.conf&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;系统配置文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.lock&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;锁定文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;归档和压缩文件&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;后缀&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;文件&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.zip&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;zip压缩文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.tar&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;归档文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.gz&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;gzip命令产生的压缩文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.bz2&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;bzip2命令产生的压缩文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;程序和脚本文件&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;后缀&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;文件&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.c&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;C语言源程序代码文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.cpp&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;C++语言源程序代码文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.o&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;程序对象文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.so&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;库文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.sh&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;Shell脚本文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;多媒体文件&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;后缀&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;文件&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.gif&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;gif图像文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.jpg&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;GPEG图像文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.png&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;png图像文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.htm或html&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;HTML超文本文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;.wav&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;音频波形文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;权限\&#34;&gt;权限&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;读取权限：r 、写入权限：w 、执行权限：x&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;字母表示法&lt;br&gt;\n&lt;code&gt;- rwx rwx rwx&lt;/code&gt; 文件权限一共10个字符，中间无空格&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;第一个字符：文件类型。&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;字符&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;文件类型&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;普通文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;d&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;目录文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;l&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;连接文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;b&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;块设备文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;c&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;字符设备文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;后面每三个一组，分别表示 当前用户 u，用户所在的组 g，其他 o&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;数字表示法&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;权限&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;数字&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;r/读&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;4&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;w/写&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;x/执行&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改权限&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;chmod 数字模式 文件&lt;br&gt;\n&lt;code&gt;chmod 755 file&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;chmod 功能模式 文件&lt;br&gt;\n&lt;code&gt;chmod g-w file&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;功能模式&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;对象：&lt;br&gt;\n&lt;code&gt;u&lt;/code&gt; 文件所有者 user&lt;br&gt;\n&lt;code&gt;g&lt;/code&gt; 同组用户   group&lt;br&gt;\n&lt;code&gt;o&lt;/code&gt; 其他用户   other&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;操作符:&lt;br&gt;\n&lt;code&gt;+&lt;/code&gt; 增加权限&lt;br&gt;\n&lt;code&gt;-&lt;/code&gt; 删除权限&lt;br&gt;\n&lt;code&gt;=&lt;/code&gt; 赋予权限&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;权限：&lt;br&gt;\nr/读：4&lt;br&gt;\nw/写：2&lt;br&gt;\nx/执行：1&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;chgrp 组群 文件&lt;/code&gt; ：改变文件所属组群&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;chown 文件所有者[:组群] 文件&lt;/code&gt; ：改变文件所有者，并可一并修改文件的所属组群&lt;br&gt;\n&lt;code&gt;# chown ding:ding f1&lt;/code&gt; ：把文件f1的 所有者 和 组群 一并改为 ding&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;基础文件命令\&#34;&gt;基础文件命令&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;创建目录  mkdir&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    mkdir [选项] 目录  \n            -m 创建目录的同时设置目录的访问权限\n            -p 一次创建多级目录      \n    例：\n        mkdir -p ding/f\n        rmdir -p ding/f     \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;移动或重命名目录   mv&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    mv [选项] 源文件或目录 目标文件或目录\n        -b   若存在同名文件，则在覆盖之前备份原来的文件\n        -f   强制覆盖同名文件\n    例：\n        mv pict picture  改名\n        mv file ding/    将file文件移动到ding目录\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;复制文件或目录   cp&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    cp [选项] 源文件或目录 目标文件或目录\n        -b   若存在同名文件，则在覆盖之前备份原来的文件\n        -f   强制覆盖同名文件\n        -r/-R  按递归方式，保留原目录结构复制文件\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;删除文件或目录   rm&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    rm [选项] 文件或目录\n        -f      强制删除，不需要确认\n        -r/-R   按递归方式删除目录\n        i       再次确认是否删除\n    例：\n        rm -rf /*\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;立链接文件，默认硬链接  ln&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    ln [选项] 目标文件 链接文件\n        -b  若存在同名，则覆盖前先备份\n        -s  建立符号链接文件\n    例：\n        ln -s /etc/passwd passwd.lnk\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查找：find 查找文件/grep 查找内容&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;find   查找文件或目录&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    find [路径] 表达式    从指定路径开始向下搜索满足表达式的文件和目录。不指定路径，则查找当前目录\n        -name 文件           按文件名查找，可使用通配符       locate 与 find -name相同\n        -group 组群名        查找文件所属组群为指定组群的文件\n        -user 用户名         查找文件所有者为指定用户的文件\n        -type 文件类型       按文件类型查找，d为目录文件，l为链接文件\n        -size [+|-]文件大小  查找指定大小的文件，+ 表示超过，-表示不足\n    例：     \n        find -name f*   从当前目录查找 f 开头的文件\n        find /etc -name fs*  \n        find -type l\n        find -size +100k\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;grep   查找指定文件中的字符串&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    grep [选项] 字符串 文件列表      从指定文件中查找符合条件的字符串，默认显示字符串所在的行\n        -n     显示行号\n        -v     显示不包含指定字符串的行\n        -i     查找是不区分大小写\n    例：\n        grep -n root /etc/passwd   查找passwd中包含 root 的行，并显示行号\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;显示文件大小，默认以KB为单位  du&lt;br&gt;\ndu [选项] [目录或文件]&lt;br&gt;\n-a  显示指定目录及所有子目录和文件的大小，默认只显示目录的大小&lt;br&gt;\n-h  以易读的方式显示目录或文件的大小，加上单位&lt;br&gt;\n-s  只显示指定目录的大小，而不显示子目录的大小&lt;br&gt;\n例：&lt;br&gt;\ndu -sh /home/ding&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;归档和压缩\&#34;&gt;归档和压缩&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;tar [] 文件名&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;命令&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;选项&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;功能&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;tar&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;选项&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;归档/压缩文件 文件或目录列表&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-c&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;创建归档文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-t&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;显示归档文件的内容&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-x&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;还原归档文件中的目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-v&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;显示归档命令的执行过程&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-z&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;采用gzip方式压缩/解压缩归档文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-j&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;采用bzip2方式压缩/解压缩归档文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-f&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;tar命令必须的选项&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;例：&lt;br&gt;\n&lt;code&gt;tar -cf etc.tar /etc/*.conf&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;tar -czf etc.tar.gz /etc/*.conf&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;gzip [] 文件名&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;命令&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;选项&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;功能&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;gzip&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;压缩或解压文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;gzip&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;[选项]&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;文件或目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-d&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;解压缩文件，相当于gunzip命令&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-r&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;参数为目录是，按目录结构递归压缩目录中的所有文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-v&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;显示文件的压缩比例&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;例：&lt;br&gt;\n&lt;code&gt;gzip 文件名&lt;/code&gt; 压缩或解压缩格式为 .gz的文件。压缩完后会删除源文件&lt;br&gt;\n&lt;code&gt;gzip *&lt;/code&gt;    压缩当前目录所有文件，没有归档功能，压缩多个文件时每个都是.gz压缩文件&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;bzip2 [] 文件名&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;命令&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;选项&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;功能&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;bzip2&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;压缩或解压文件&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;bzip2&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;[选项]&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;文件或目录&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-d&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;解压缩文件，相当于bunzip2命令&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-v&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;显示文件的压缩比例&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;例：&lt;br&gt;\n&lt;code&gt;bzip2 文件名&lt;/code&gt; 压缩或解压缩格式为 .bz2的文件。压缩完后会删除源文件&lt;br&gt;\n&lt;code&gt;bzip2 *.bz2&lt;/code&gt; 解压当前文件夹所有bz2文件`&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;zip [选项] 压缩文件 文件列表&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  -m  压缩完后删除源文件\n  -r  地柜压缩\n  \n  例：\n      zip file.zip *\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;unzip [选项] 压缩文件&lt;/code&gt;     解压缩.zip文件&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;  -l       查看压缩文件所包含的文件\n  -t       测试压缩文件是否已损坏\n  -d 目录名   指定解压缩的目标目录 \n  -n       不覆盖同名文件\n  -o       强制覆盖同名文件\n  例：\n      unzip -d dir file.zip   解压到dir目录\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;rpm软件包\&#34;&gt;RPM软件包&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;安装RPM软件包\n    rpm -i[选项] 软件包文件\n        -v      显示安装过程\n        -h      以 # 表示安装进度\n        -replacepkgs    重复安装软件包  \n\n查询RPM软件包\n    rpm -q[选项] 软件包\n        -l      查询已安装软件包所包含的所有文件\n        -i      查询已安装软件包的详细信息\n        -a      查询已安装的所有软件包\n        -f 文件名  查询指定文件所属的软件包\n\n删除RPM软件包\n    rpm -e 软件包\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;yum命令管理软件包\&#34;&gt;YUM命令管理软件包&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;安装软件包/软件包集\n    yum install 软件包名\n    yum groupinstall 软件包集名\n\n安装vsftpd软件包\n    yum install vsftpd\n\n查询软件包/软件包集信息\n    yum info 软件包名\n    yum groupinfo 软件包集名\n\n查询vsftpd软件包的信息\n    yum info vsftpd\n\n删除软件包/软件包集\n    yum remove 软件包名     删除RPM软件包\n    yum groupremove 软件包集名     删除RPM软件包集\n    yum remove vsftpd     删除vsftpd软件包\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;进程管理\&#34;&gt;进程管理&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;进程：是具有独立功能的程序的一次运行过程&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;一个程序可启动多个进程，一个进程可调用多个程序&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;进程的优先级的取值范围：-20~19&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;进程的状态：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;    就绪状态：进程已获得除CPU外的运行所需的全部资源\n    运行状态：进程占用CPU正在运行\n    等待状态：进程正在等待某一事件或某一资源\n\n    进程同步：相关进程为协作文成同一任务而引起的直接制约关系\n    进程互斥：进程间因竞争系统资源而引起的间接制约关系\n    进程死锁：对资源保持请求、对资源的循环等待、对资源的非抢占式分配、资源的独占使用\n\n    挂起状态：正在运行的进程，因为某个原因失去CPU而暂时停止运行、\n    终止状态：进程已结束\n    休眠状态：进程主动暂时停止运行\n    僵死状态：进程已停止运行，但是相关控制信息仍保留\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;作业：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;概念&lt;br&gt;\n正在执行的一个或多个相关进程可形成一个作业&lt;br&gt;\n一个作业可启动多个进程&lt;br&gt;\n作业分前台作业和后台作业&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Shell的命令的末尾加上一个 &amp;amp; 符号，将启动一个后台作业&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    jobs [选项]   显示当前所有的作业\n        -p     仅显示作业号\n        -l     显示进程号和作业号\n    bg [作业号]   将前台作业切换到后台运行，若未指定作业号，则将当前作业切换到后台\n    fg [作业号]   将前台作业切换到前台运行，若未指定作业号，则将当前作业切换到前台\n  \n    例：\n        vi f1       编辑文件f1\n        Ctrl z      挂起vi\n        jobs -l     显示进程号和作业号\n        bg 1        将作业切换到后台\n        Ctrl z      挂起vi\n        fg 1        将作业再切换到前台\n  \n    ps [选项]     显示进程的状态，无选项时显示当前用户在当前终端启动的进程\n        -a      显示当前终端上所有的进程\n        -A      显示系统所有进程，包括其他用户进程和系统进程\n        -l      显示进程的详细信息、包括父进程号、进程优先级等\n        u       显示包括进程的所有者在内的详细信息\n        x       显示后台进程的信息\n        -t 终端号 显示指定终端上的进程信息\n  \n    pstree [选项]   以树形图显示进程之间的相互关系\n            -a      显示启动进程的命令行\n            -n      按照进程号进行排序\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;终止正在运行的进程，超级用户可终止所有进程，普通用户只能终止自己的进程&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    kill % 作业号\n    kill [选项] 进程号    选项填数字\n        HUP   1    终端断线\n        INT   2    中断（同 Ctrl + C）\n        QUIT  3    退出（同 Ctrl + \\）\n        TERM  5    终止\n        KILL  9    强制终止\n        CONT  8    继续（与STOP相反， fg/bg命令）\n        STOP  9    暂停（同 Ctrl + Z）\n    例：\n        kill -9 2638   强行终止2638进程\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;进程调度\&#34;&gt;进程调度&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;at调度&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;at [选项] [时间]\n    -l  显示等待执行的调度作业\n    -d  删除指定的调度作业\n进程的执行时间可表示为：1.绝对计时法：HH:MM(24时制)、HH:MM(12时制加AM/PM) 日期写在时间后面，格式为：月日年\n例：\n    at 23:59 01012018\n    at&amp;gt;wall Happy New Year!      输入at调度后会出现 at&amp;gt; 提示符， 输入完成后按 Ctrl D\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;batch调度&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    在系统空间时运行，适合时间上要求不高，但运行时占系统资源较多的工作 \n    输入batch还是出现 at&amp;gt; 提示符， 输入完成后按 Ctrl D\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;cron调度&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    at和batch调度的命令智能执行一次，cron调度能重复执行\n    cron调度与crond进程、crontab命令和crontab配置文件有关\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;crontab配制文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    保存在/var/spool/cron 目录中，文件名与用户名相同\n    也即halen用户的crontab配置文件为/vwr/spool/crontab/helen\n    crontab配置文件保留cron调度的内容，每行表示一个调度任务，每个调度任务包括六项字段\n      字段：   分钟   时    日期    月份      星期          命令   (倒着：星期，月日时分)\n    取值范围： 0-59  0-23  01-31   01-12  0-6(0是星期天)  \n    \n    &amp;quot;-&amp;quot;符号表示一段时间    &amp;quot;,&amp;quot;符号表示指定时间，如5,15,25     &amp;quot;/&amp;quot;表示时间的间隔，如日期栏中输入 */3 表示每隔三天\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;crontab [选项]   管理crontab配置文件\n        -e  创建并编辑crontab配置文件\n        -l  显示crontab配置文件的内容\n        -r  删除crontab配置文件\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;crond 进程&lt;br&gt;\n```&lt;br&gt;\ncrond进程在系统启动时自动启动，并一直运行在后台，负责检测crontab配置文件，并按照其设置内容定期重复执行cron的调度工作&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt; ```\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;实施系统监视的Shell命令&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    who [选项]   查看当前已登录的所有用户\n        -H  显示出信息标题行\n    \n    top [-d 秒数]   动态显示CPU利用率、内存利用率和考必过状态等相关信息，默认每5s更新显示信息。-d 秒数 可以指定更新间隔\n    \n    free [选项]     显示内存和交换分区的使用情况\n        -m    以MB为单位显示，默认以KB为单位\n        -t    增加显示内存和交换分区的总数和信息\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;思考题-cron调度\&#34;&gt;思考题  (cron调度)&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;(1) 下午4:50删除/abc 目录下的全部子目录和全部文件\n      50 16 * * * rm -rf /abc/*\n\n(2) 早8:00--下午6:00 每小时一次将/xyz 目录下 x1 文件的最后5行加入到/backup 目录下的 back01.txt\n      0 8-18 * * *  tail -5 /xyz/x1 &amp;gt;&amp;gt; /backup/back01.txt\n\n(3) 每周一下午5:50将/data 目录下的所有目录和文件归档并压缩为文件 backup.tar.gz\n      50 17 * * 1 tar -czvf backup.tar.gz /data         v是显示执行过程 \n                                                        f是必带选项 \n                                                        c是归档 \n                                                        z是gzip压缩&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;linux-zhi-shi-zheng-li&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;整理巩固一下Linux的知识&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Linux知识整理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2018-07-24 16:40:55&#34;,&#34;dateFormat&#34;:&#34;2018-07-24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/linux-zhi-shi-zheng-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;22 min read&#34;,&#34;time&#34;:1282000,&#34;words&#34;:5689,&#34;minutes&#34;:22},&#34;description&#34;:&#34;前言\n\n整理巩固一下Linux的知识\n\n\n简介\n\n\n特点：多用户多任务、良好的兼容性、可移植性强、稳定性高、界面美观\n\n\n版本：X.Y.Z  主版本号、次版本号(偶数是正式版本，奇数是测试版本不稳定)、修改次数\n\n\n系统结构\n\n\n\nLinu...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4\&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vim%E7%BC%96%E8%BE%91%E5%99%A8\&#34;&gt;vim编辑器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB\&#34;&gt;运行级别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E6%88%B7%E5%92%8C%E7%BE%A4%E7%BB%84\&#34;&gt;用户和群组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%B9%E9%87%8F%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7\&#34;&gt;批量创建多个用户&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\&#34;&gt;文件系统&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9D%83%E9%99%90\&#34;&gt;权限&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4\&#34;&gt;基础文件命令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%92%E6%A1%A3%E5%92%8C%E5%8E%8B%E7%BC%A9\&#34;&gt;归档和压缩&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rpm%E8%BD%AF%E4%BB%B6%E5%8C%85\&#34;&gt;RPM软件包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#yum%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85\&#34;&gt;YUM命令管理软件包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\&#34;&gt;进程管理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\&#34;&gt;进程调度&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%9D%E8%80%83%E9%A2%98-cron%E8%B0%83%E5%BA%A6\&#34;&gt;思考题  (cron调度)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;学习Python，需要用Linux，这里说一下我我遇到的各种坑&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;python版本更改\&#34;&gt;Python版本更改&lt;/h2&gt;\n&lt;p&gt;参考文章：&lt;a href=\&#34;https://blog.csdn.net/fang_chuan/article/details/60958329\&#34;&gt;遥远的她&lt;/a&gt; 和 &lt;a href=\&#34;https://github.com/eagleon/eagleon.github.com/issues/2\&#34;&gt;GitHub Issues&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;基于用户修改版本\&#34;&gt;基于用户修改版本&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;查看所拥有的Python版本&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;ls /usr/bin/python*\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看默认版本信息&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;python --version\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;修改默认版本&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;alias python=&#39;/usr/bin/python3.6&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;查看是否修改成功&lt;br&gt;\n重新登录或重新加载.bashrc文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;. ~/.bashrc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;查看Python版本：参看上述第三步&lt;/p&gt;\n &lt;!-- more --&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;vim-下-python-自动补全\&#34;&gt;VIM 下 Python 自动补全&lt;/h2&gt;\n&lt;h3 id=\&#34;参考文章niepangu和运维笔记和xpleaf\&#34;&gt;参考文章：&lt;a href=\&#34;https://blog.csdn.net/niepangu/article/details/78976243\&#34;&gt;niepangu&lt;/a&gt;和&lt;a href=\&#34;https://blog.linuxeye.cn/324.html\&#34;&gt;运维笔记&lt;/a&gt;和&lt;a href=\&#34;http://blog.51cto.com/xpleaf/1682449\&#34;&gt;xpleaf&lt;/a&gt;&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;安装pydictin插件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    wget https://github.com/rkulla/pydiction/archive/master.zip\n    unzip -q master\n    mv pydiction-master pydiction\n    mkdir -p ~/.vim/tools/pydiction\n    cp -r pydiction/after ~/.vim\n    cp pydiction/complete-dict ~/.vim/tools/pydiction\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;创建~/.vimrc文件&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    vim ~/.vimrc\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;添加配置&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    filetype plugin on\n    let g:pydiction_location = &#39;~/.vim/tools/pydiction/complete-dict&#39;\n    let g:pydiction_menu_height = 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;编辑.py文件，测试是否成功&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;使用ssh连接ubuntu\&#34;&gt;使用SSH连接Ubuntu&lt;/h2&gt;\n&lt;h3 id=\&#34;参考文章rabbittinbee\&#34;&gt;参考文章：&lt;a href=\&#34;https://blog.csdn.net/rabbittinbee/article/details/52422790\&#34;&gt;rabbittinbee&lt;/a&gt;&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;网络连通&lt;br&gt;\nWindows下查看ip cmd下:&lt;code&gt;ipconfig&lt;/code&gt;&lt;br&gt;\nUbuntu下：&lt;code&gt;ifconfig&lt;/code&gt;&lt;br&gt;\nwindows下ping Ubuntu的ip，查看是否ping通&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;Ubuntu开启SSH&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;查看是否开启SSH&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    ssh localhost\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果出现下面提示表明还没有安装&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;    ssh: connect to hostlocalhost port 22: Connection refused \n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;开启SSH&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;sudo apt-getinstall –y openssh-server \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;ubuntu安装fcitx使用小鹤双拼\&#34;&gt;Ubuntu安装fcitx使用小鹤双拼&lt;/h2&gt;\n&lt;h3 id=\&#34;参考文章点击这里\&#34;&gt;参考文章：&lt;a href=\&#34;http://besky.me/2018/1/how-to-use-double-pinyin-with-fcitx-rime-on-ubuntu\&#34;&gt;点击这里&lt;/a&gt;&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;安装fcitx&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;# 安装 fcitx-rime， 是 fcitx 社区维护的\n$ sudo apt-get install fcitx-rime\n\n# 安装双拼方案\n$ sudo apt-get insatll librime-data-double-pinyin\n\n# 配置 fcitx 为默认输入法，然后重新部署或者重启\n$ im-config\n$ sudo reboot # (如果已经装过 fcitx 就不需要重启啦，系统托盘 fcitx 图标右键重新启动即可)\n\n# 添加输入法\n$ fcitx-config-gtk3 # (一般安装好就有了，最好确认一下)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;添加小鹤方案&lt;br&gt;\n添加配置文件：&lt;code&gt;~/.config/fcitx/rime/default.custom.yaml&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;patch:\n    schema_list:\n        - schema: luna_pinyin          # 朙月拼音\n        - schema: luna_pinyin_simp     # 朙月拼音 简化字模式\n        - schema: luna_pinyin_tw       # 朙月拼音 臺灣正體模式\n        - schema: terra_pinyin         # 地球拼音 dì qiú pīn yīn\n        - schema: bopomofo             # 注音\n        - schema: jyutping             # 粵拼\n        - schema: cangjie5             # 倉頡五代\n        - schema: cangjie5_express     # 倉頡 快打模式\n        - schema: quick5               # 速成\n        - schema: wubi86               # 五笔 86\n        - schema: wubi_pinyin          # 五笔拼音混合輸入\n        - schema: double_pinyin        # 自然碼雙拼\n        - schema: double_pinyin_mspy   # 微軟雙拼\n        - schema: double_pinyin_abc    # 智能 ABC 雙拼\n        - schema: double_pinyin_flypy  # 小鶴雙拼\n        - schema: wugniu               # 吳語上海話（新派）\n        - schema: wugniu_lopha         # 吳語上海話（老派）\n        - schema: sampheng             # 中古漢語三拼\n        - schema: zyenpheng            # 中古漢語全拼\n        - schema: ipa_xsampa           # X-SAMPA 國際音標\n        - schema: emoji                # emoji 表情\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;vmnet0-vmnet1和vmnet8的区别\&#34;&gt;VMNet0、VMNet1和VMNet8的区别&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;vmnet0，实际上就是一个虚拟的网桥，这个网桥有很若干个端口，一个端口用于连接你的Host，一个端口用于连接你的虚拟机，他们的位置是对等的，谁也不是谁的网关。所以在Bridged模式下，你可以让虚拟机成为一台和你的Host相同地位的机器。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;vmnet1是host-only，也就是说，选择用vmnet1的话就相当于VMware给你提供了一个虚拟交换机，仅将虚拟机和真实系统连上了，虚拟机可以与真实系统相互共享文件，但是虚拟机无法访问外部互联；&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;vmnet8是NAT，就是网络地址转换，相当于给你一个虚拟交换机，将虚拟机和真实系统连上去了，同时这台虚拟交换机又和外部互联网相连，这样虚拟机和真是系统可以相互共享，同时又都能访问外部互联网，而且虚拟机是借用真实系统的IP上网的，不会受到IP-MAC绑定的限制。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;注意：很多人把VMnet8在宿主机比作虚拟机的路由器，这个是不对的，如果比作路由器的话，那么，虚拟机若想上网，必须把虚拟机上面的IP地址和宿主机VMnet8的ip地址相同才可以，如果那样就没有意义了，显然是不对的。所以，我们把宿主机VMnet8比作：“一个交换机，同时和外部互联网相连”。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;vs-code-编辑-python\&#34;&gt;VS Code 编辑 Python&lt;/h2&gt;\n&lt;h3 id=\&#34;乱码问题\&#34;&gt;乱码问题&lt;/h3&gt;\n&lt;p&gt;参考文章：&lt;a href=\&#34;https://www.cnblogs.com/zhaoshizi/p/9050768.html\&#34;&gt;zhaoshizi&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;首选项中把&lt;code&gt;code-runner.executorMap&lt;/code&gt;设置为&lt;code&gt;&amp;quot;python&amp;quot;:&amp;quot;set PYTHONIOENCODING=utf-8 &amp;amp;&amp;amp; python&amp;quot;&lt;/code&gt;&lt;br&gt;\n完美解决&lt;/p&gt;\n&lt;h3 id=\&#34;配置教程\&#34;&gt;配置教程&lt;/h3&gt;\n&lt;p&gt;参考文章：&lt;a href=\&#34;https://zhuanlan.zhihu.com/p/31417084\&#34;&gt;浪晋&lt;/a&gt;&lt;/p&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;vim下按-ctrls-后假死的解决方法\&#34;&gt;VIM下按 Ctrl+s 后假死的解决方法&lt;/h2&gt;\n&lt;h3 id=\&#34;ctrlq-退出假死\&#34;&gt;Ctrl+q 退出假死&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;使用vim时，如果你不小心按了 Ctrl + s后，你会发现不能输入任何东西了，像死掉了一般，其实vim并没有死掉，这时vim只是停止向终端输出而已，要想退出这种状态，只需按Ctrl + q 即可恢复正常。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr&gt;\n&lt;h2 id=\&#34;持续更新中\&#34;&gt;持续更新中。。。&lt;/h2&gt;\n&#34;,&#34;fileName&#34;:&#34;ubuntu-python&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;学习Python，需要用Linux，这里说一下我我遇到的各种坑&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Ubuntu下修改Python版本&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Python&#34;,&#34;slug&#34;:&#34;j0sauiBVm&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/j0sauiBVm/&#34;},{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;PmmJD2zWp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/PmmJD2zWp/&#34;}],&#34;date&#34;:&#34;2018-07-16 16:15:30&#34;,&#34;dateFormat&#34;:&#34;2018-07-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/ubuntu-python/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:267000,&#34;words&#34;:1125,&#34;minutes&#34;:5},&#34;description&#34;:&#34;前言\n\n学习Python，需要用Linux，这里说一下我我遇到的各种坑\n\n\nPython版本更改\n参考文章：遥远的她 和 GitHub Issues\n基于用户修改版本\n\n\n查看所拥有的Python版本\nls /usr/bin/python*...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#python%E7%89%88%E6%9C%AC%E6%9B%B4%E6%94%B9\&#34;&gt;Python版本更改&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E4%BF%AE%E6%94%B9%E7%89%88%E6%9C%AC\&#34;&gt;基于用户修改版本&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vim-%E4%B8%8B-python-%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8\&#34;&gt;VIM 下 Python 自动补全&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0niepangu%E5%92%8C%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0%E5%92%8Cxpleaf\&#34;&gt;参考文章：niepangu和运维笔记和xpleaf&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8ssh%E8%BF%9E%E6%8E%A5ubuntu\&#34;&gt;使用SSH连接Ubuntu&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0rabbittinbee\&#34;&gt;参考文章：rabbittinbee&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ubuntu%E5%AE%89%E8%A3%85fcitx%E4%BD%BF%E7%94%A8%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC\&#34;&gt;Ubuntu安装fcitx使用小鹤双拼&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%E7%82%B9%E5%87%BB%E8%BF%99%E9%87%8C\&#34;&gt;参考文章：点击这里&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vmnet0-vmnet1%E5%92%8Cvmnet8%E7%9A%84%E5%8C%BA%E5%88%AB\&#34;&gt;VMNet0、VMNet1和VMNet8的区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vs-code-%E7%BC%96%E8%BE%91-python\&#34;&gt;VS Code 编辑 Python&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98\&#34;&gt;乱码问题&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B\&#34;&gt;配置教程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vim%E4%B8%8B%E6%8C%89-ctrls-%E5%90%8E%E5%81%87%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\&#34;&gt;VIM下按 Ctrl+s 后假死的解决方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ctrlq-%E9%80%80%E5%87%BA%E5%81%87%E6%AD%BB\&#34;&gt;Ctrl+q 退出假死&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD\&#34;&gt;持续更新中。。。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;对于有码字需求的用户来说，可能早已经厌烦了全拼的输入方式了，今天，我写篇博客，随便说一说我了解的输入法吧！&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;不详细介绍输入法，只是我的一些推荐&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;致力于让 输入法懂我们的心意&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1fvkzh6ej4tj312w0dwwg8.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;输入法推荐\&#34;&gt;输入法推荐&lt;/h2&gt;\n&lt;p&gt;废话不多说，直开始荐吧。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;如果能下得去决心练习，那就直接上形码输入法。关于形码输入法自己挑选吧。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;如果想更容易上手，那就双拼吧，在这里我推荐小鹤双拼。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;小鹤双拼的进阶可以加上鹤形，基本能做到不用选字了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;个人经历\&#34;&gt;个人经历&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;我接触的输入法有全拼，双拼，五笔。很长时间以来，都是用全拼输入法，速度的话还算过得去， 但是依靠词库依旧不能摆脱选词的烦恼，可谓是苦不堪言吧！在你正畅快的输入的时候，可能眼睛还没反应过来， 文本所对应的词或句子就被你按下了空格键，等你反应过来你输入的首选上屏的文本有问题的时候你就多次按删除键， 然后一直重复着这个步骤。所以换输入法的思绪萦绕在脑海中许久，所以有了接下来五笔的学习。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;五笔输入法其实是一个让人又爱又恨的输入法，因为它需要投入的精力和一段时间内获得的收获简直不成正比，在我初学五笔输入法的时候，其实算是入门了吧，因为想打的字我大部分都能打出来，但是使用五笔却一直也没赶上我用全拼的时候。学五笔，背完了字根，记住了一级简码，二级简码，了解了拆分原则， 这确依旧不够，如果按时间来算的话，完成这些你只相当于完成了整个五笔历程的百分之一，或许是距离百分之一也相差甚远， 因为要提高速度需要您及其大量的时间去练习每个字的拆分，直到形成肌肉记忆，提高击键和形成肌肉记忆，这没有几十万字是下不来的。可想而知这是一个多么大的工作量了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;小鹤学习\&#34;&gt;小鹤学习&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;a href=\&#34;http://www.flypy.com\&#34;&gt;小鹤官网&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;双拼简介：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;是一种建立在拼音输入法之上的输入法，可视为全拼的改进&lt;/li&gt;\n&lt;li&gt;把拼音中的声母或韵母各自映射到某个按键上&lt;/li&gt;\n&lt;li&gt;使得每个字音都可以用最多两次按键打出&lt;/li&gt;\n&lt;li&gt;如：小：xn　鹤：he　双：ul　拼：pb&lt;/li&gt;\n&lt;li&gt;相比于全拼，少了大部分击键，能极大的提升输入速度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;我目前所用的是小鹤音形（挂接搜狗输入法）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;入手的话我推荐从音形直接入手。因为这样可以节省很多选字的烦恼&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;暂时不想学习形码的用户也可以学习小鹤纯双拼&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;我于此只做一个引导，具体的折腾看你们自己的了。附上&lt;a href=\&#34;http://www.flypy.com\&#34;&gt;小鹤官网&lt;/a&gt;，望自主学习。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;shuang-pin&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;对于有码字需求的用户来说，可能早已经厌烦了全拼的输入方式了，今天，我写篇博客，随便说一说我了解的输入法吧！&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;不详细介绍输入法，只是我的一些推荐&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;致力于让 输入法懂我们的心意&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://ws1.sinaimg.cn/large/006iOFs0gy1fvkzh6ej4tj312w0dwwg8.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;title&#34;:&#34;双拼输入法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;输入法&#34;,&#34;slug&#34;:&#34;m7l0z5_Xq&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/m7l0z5_Xq/&#34;}],&#34;date&#34;:&#34;2018-07-09 20:28:44&#34;,&#34;dateFormat&#34;:&#34;2018-07-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/shuang-pin/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:162000,&#34;words&#34;:808,&#34;minutes&#34;:3},&#34;description&#34;:&#34;前言\n\n对于有码字需求的用户来说，可能早已经厌烦了全拼的输入方式了，今天，我写篇博客，随便说一说我了解的输入法吧！\n\n\n不详细介绍输入法，只是我的一些推荐\n\n\n致力于让 输入法懂我们的心意\n\n\n\n输入法推荐\n废话不多说，直开始荐吧。\n\n\n如...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BE%93%E5%85%A5%E6%B3%95%E6%8E%A8%E8%8D%90\&#34;&gt;输入法推荐&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AA%E4%BA%BA%E7%BB%8F%E5%8E%86\&#34;&gt;个人经历&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E9%B9%A4%E5%AD%A6%E4%B9%A0\&#34;&gt;小鹤学习&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;记录一些搜索引擎使用技巧&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;具体使用\&#34;&gt;具体使用&lt;/h2&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;表达式&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;用途&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;实例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;“”(双引号)&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索词放在双引号中，代表完全匹配搜索&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;“keyword”&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;*（通配符）&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;代表任何文字，比如想查找“锤*手机&amp;quot;，可以搜索到锤子手机，锤xx手机等&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;“锤*手机”&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;+（与）&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索所有包含关键词“keyword1”和“keyword2**”的中文网页&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;“keyword1 keyword2” 或者“keyword1+keyword2”&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-（非）(A -B)&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索去除keyword2的keyword1&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;“keyword1 -keyword2”&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;OR(或)&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索 A 或者 B&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;“keyword1 OR keyword2”&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;~keyword1&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索它的同义词&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;~喜欢&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;~keyword1-keyword2&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;只搜索同义词,不要原词&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;~WORD-WORD&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;site:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索指定域名的内容&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;site:www.github.com keyword 或者keyword site:www.github.com&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;filetype:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;限制搜索的词语是网页中链接内包含的关键词&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;filetype:pdf ios开发&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;link:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索网页中含有某链接的结果,实例中的结果为包含百度这个链接的页面&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;link:http://baidu.com&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;inurl:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索网站地址中包含关键词词的结果&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;inurl:搜索引擎优化&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;intitle&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索标题中包含关键词词的结果&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;intitle:搜索引擎优化&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;related:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;搜索相关网站&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;related:qidian.com&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;intext:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;限制搜索的词语是网页内文包含的关键词&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;index of&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;根据输入的内容返回一些资源列表&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;index of mp3&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;inanchor:keyword&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;指令返回的结果是导入链接锚文字中包含搜索词的页面&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;inanchor:关于我们&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;-filetype:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;-filetype:SOMEFILETYPE = 剔除指定文件类型&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;-filetype:SOMEFILETYPE&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;allinanchor:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;限制搜索的词语是网页中链接内包含的关键词（可使用多个关键词）&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;allinanchor:keyword1 keyword2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;allintext:&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;限制搜索的词语是网页内文包含的关键词（可使用多个关键词）&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;allintext:keyword1 keyword2&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&#34;,&#34;fileName&#34;:&#34;search-engine&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;记录一些搜索引擎使用技巧&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;搜索引擎使用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;输入法&#34;,&#34;slug&#34;:&#34;m7l0z5_Xq&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/m7l0z5_Xq/&#34;}],&#34;date&#34;:&#34;2018-07-07 22:09:06&#34;,&#34;dateFormat&#34;:&#34;2018-07-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/search-engine/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:100000,&#34;words&#34;:436,&#34;minutes&#34;:2},&#34;description&#34;:&#34;前言\n\n记录一些搜索引擎使用技巧\n\n\n具体使用\n\n\n\n表达式\n用途\n实例\n\n\n\n\n“”(双引号)\n搜索词放在双引号中，代表完全匹配搜索\n“keyword”\n\n\n*（通配符）\n代表任何文字，比如想查找“锤*手机&amp;quot;，可以搜索到锤子手机...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8\&#34;&gt;具体使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;随便整理的一些自用的Git指令&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;github创建仓库提示代码\&#34;&gt;GitHub创建仓库提示代码&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;echo &amp;quot;# 项目名&amp;quot; &amp;gt;&amp;gt; README.md\ngit init\ngit add README.md\ngit commit -m &amp;quot;first commit&amp;quot;\ngit remote add origin git@github.com:qiubaiying/项目名.git\ngit push -u origin master\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;若仓库存在直接push&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;git remote add origin git@github.com:qiubaiying/test.git\ngit push -u origin master\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;常用操作\&#34;&gt;常用操作&lt;/h2&gt;\n&lt;h3 id=\&#34;生成-ssh-key-详细-csdn\&#34;&gt;生成 SSH Key, 详细: &lt;a href=\&#34;https://blog.csdn.net/xiehd313/article/details/81110551\&#34;&gt;CSDN&lt;/a&gt;&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;生成多个 SSH Key 并重命名(生成一个则不需要 f 选项)\n$ ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot; -f ~/.ssh/id_rsa_github\n$ ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot; -f ~/.ssh/id_rsa_gitlab\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;创建仓库初始化\&#34;&gt;创建仓库（初始化）&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;在当前指定目录下创建\ngit init\n\n新建一个仓库目录\ngit init [project-name]\n\n克隆一个远程项目\ngit clone [url]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;添加文件到缓存区\&#34;&gt;添加文件到缓存区&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;添加所有变化的文件\ngit add .\n\n添加名称指定文件\ngit add text.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;配置\&#34;&gt;配置&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;设置提交代码时的用户信息\ngit config [--global] user.name &amp;quot;[name]&amp;quot;\ngit config [--global] user.email &amp;quot;[email address]&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;提交\&#34;&gt;提交&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;提交暂存区到仓库区\ngit commit -m &amp;quot;msg&amp;quot;\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;远程同步\&#34;&gt;远程同步&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;分支\&#34;&gt;分支&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;标签tags\&#34;&gt;标签Tags&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;添加标签 在当前commit\ngit tag -a v1.0 -m &#39;xxx&#39; \n\n添加标签 在指定commit\ngit tag v1.0 [commit]\n\n查看\ngit tag\n\n删除\ngit tag -d V1.0\n\n删除远程tag\ngit push origin :refs/tags/[tagName]\n\n推送\ngit push origin --tags\n\n拉取\ngit fetch origin tag V1.0\n\n新建一个分支，指向某个tag\ngit checkout -b [branch] [tag]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;查看信息\&#34;&gt;查看信息&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其&amp;quot;提交说明&amp;quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &amp;quot;@{0 day ago}&amp;quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;撤销\&#34;&gt;撤销&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;其他\&#34;&gt;其他&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;# 生成一个可供发布的压缩包\n$ git archives&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;git&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;前言\&#34;&gt;前言&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;随便整理的一些自用的Git指令&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Git 指令&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Git&#34;,&#34;slug&#34;:&#34;ERK0vjfE6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://dgzd.github.io/tag/ERK0vjfE6/&#34;}],&#34;date&#34;:&#34;2018-07-07 11:44:28&#34;,&#34;dateFormat&#34;:&#34;2018-07-07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://dgzd.github.io/post/git/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:370000,&#34;words&#34;:1476,&#34;minutes&#34;:7},&#34;description&#34;:&#34;前言\n\n随便整理的一些自用的Git指令\n\n\nGitHub创建仓库提示代码\necho &amp;quot;# 项目名&amp;quot; &amp;gt;&amp;gt; README.md\ngit init\ngit add README.md\ngit commit -m ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%89%8D%E8%A8%80\&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#github%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E6%8F%90%E7%A4%BA%E4%BB%A3%E7%A0%81\&#34;&gt;GitHub创建仓库提示代码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\&#34;&gt;常用操作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E6%88%90-ssh-key-%E8%AF%A6%E7%BB%86-csdn\&#34;&gt;生成 SSH Key, 详细: CSDN&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96\&#34;&gt;创建仓库（初始化）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E5%88%B0%E7%BC%93%E5%AD%98%E5%8C%BA\&#34;&gt;添加文件到缓存区&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%90%E4%BA%A4\&#34;&gt;提交&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5\&#34;&gt;远程同步&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E6%94%AF\&#34;&gt;分支&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%87%E7%AD%BEtags\&#34;&gt;标签Tags&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E7%9C%8B%E4%BF%A1%E6%81%AF\&#34;&gt;查看信息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%92%A4%E9%94%80\&#34;&gt;撤销&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96\&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->



</html>