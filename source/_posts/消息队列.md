---
title: 消息队列
date: 2019-03-28 09:44:54
tags:
    - 消息队列
categories: 消息队列
encrypt:
description:
---

{% cq %} 前言 {% endcq %}

{% note info %}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息队列简介
{% endnote %}

<!-- more -->

# 消息队列



## 什么是消息队列

例如：

1. 服务员点菜快，厨师做菜慢，服务员只需要给厨师点菜单即可，然后就可以继续去服务谷歌，不需要等待厨师把菜做完。点菜单就相当于消息，放单子的位置就相当少队列。
2. 业务系统需要发短信，但短信发送模块速度跟不上，业务系统就可以吧发送短信的两个人信息封装为一个消息，放入队列，短信发送模块从队列中获取消息进行处理



MQ，是一种跨进程的通信机制，用于上下游传递消息。

在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。

使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。

[使用场景](https://blog.csdn.net/qq_35152037/article/details/80012961)

 

消息队列（Message Queue）是一种不同应用程序之间（跨进程）的通信方式。应用程序通过写入和检索出入列队的数据（消息）来通信，而无需通过专用链接来连接它们。

消息发送后可以立即返回，由消息系统来确保信息的可靠传递，消息发布者只管把消息发布到 MQ 中而不管谁来取，消息使用者只管从 MQ 中区消息而不管谁发布的，发布者和使用者都不知道对方的存在



**消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。**

直接调用通常是用于诸如 **远程过程调用** (Remote Procedure Call. RPC)的技术。

排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求，这样天然的就实现了异步的目标。



## 为什么要使用消息队列

* 解耦、异步、削峰
* 参考：[为什么要使用 MQ](https://blog.csdn.net/weixin_40753536/article/details/82383304)、[什么是消息队列](https://blog.csdn.net/qq_34288630/article/details/79411529)、[消息队列的功能场景 - 京东技术](https://www.liangzl.com/get-article-detail-1992.html) 、[消息队列会遇到的问题](https://blog.csdn.net/alinshen/article/details/80583214)



### 解耦

**传统模式的缺点**：系统间耦合性太强，

**中间件模式的优点**：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而实现解耦。

![](https://ws1.sinaimg.cn/large/006iOFs0gy1g1om5zqkf1j30hi06xmy0.jpg)

**业务中的使用场景**：订单系统生成订单，推送到 MQ 后立即返回，结算系统从 MQ 拉取订单并处理

MQ最直接的使用场景就是可以将两个系统进行解耦，比如我们的货款抵扣业务场景，用户生成订单发送MQ后立即返回，结算系统去消费该MQ进行用户账户金额的扣款。这样订单系统只需要关注把订单创建成功，最大可能的提高订单量，并且生成订单后立即返回用户。而结算系统重点关心的是账户金额的扣减，保证账户金额最终一致。这个场景里面还会涉及到重试幂等性问题



### 异步

**传统模式**：一些非必要的业务逻辑以同步的方式运行，太耗费时间。 

**中间件模式**：将消息写入消息队列，使非必要的业务逻辑以异步的方式运行，加快响应速度 

**业务中的使用场景**：订单系统

用户点击 【下单】按钮后的业务逻辑包括：扣减库存、生成相应的订单数据、下单、发送消息通知等

在业务发展的初期，这些逻辑可能放在一起同步执行，但随着业务的整张，，需要提升系统服务的性能，这时候可以将一些不需要立即生效的操作拆分出来异步执行，比如发送消息等。这种场景就可以使用 MQ，在下单的主流程(比如扣减库存、生成相应的单据) 完成之后，发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取 MQ 的消息 ( 或者让 MQ 推送消息 )

上述订单系统中，把下单后发送消息通知存放到 MQ ，通过另外的线程单独调用，就是异步的体现



### 削峰

**传统模式**：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常

**中间件模式**：把要处理的请求放入MQ，系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。

**业务中的使用场景**：平衡高并发时期的流量

还是以订单系统和结算系统场景为例，如果订单系统通过RPC框架来调用结算系统，在有高峰促销的情况下生成订单的量会非常大，而且由于生成订单的速度也非常快，这样势必会给结算系统造成系统压力，服务器利用率则会偏高，但在不是高峰的时间点订单量比较小，结算系统的服务器利用率则会偏低。



## 消息队列的优缺点

参考：[什么是消息队列](https://blog.csdn.net/qq_34288630/article/details/79411529)

### 为什么要分布式消息队列

1. 多系统协作需要分布式

   例如消息队列的数据需要在多个系统之间共享，所以需要提供分布式通信机制，协同机制

2. 可靠

   消息会被持久化到分布式存储中，这样避免了单台机器存储的消息由于机器问题导致的消息丢失

3. 可扩展

   分布式消息队列，会随着访问量的增加而方便的增加处理服务器

### 优点

1. 提高系统响应速度

   使用消息队列，生产者一方把消息往消息队列里一扔，就可以立马返回响应用户，无需等待处理结果

2. 保证消息的传递

   如果发送消息时接收者不可用，消息队列就会保留消息，直到成功的传递它

3. 解耦

   只要信息格式不变，即使接收者的接口、位置、或者配置改变，也不会给发送者带来任何改变 
   消息发送者无需知道消息接收者是谁，使得系统设计更清晰 

### 缺点

**系统可用性降低**

本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低 

**系统复杂性增加**

要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。 

但是，我们该用还是要用的。



## 常见问题

参考：[消息队列会遇到的问题](https://blog.csdn.net/alinshen/article/details/80583214)

### 如何保证消息队列是高可用

分析：引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。
回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。 
以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。

至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。 
要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。

### 如何保证消息不被重复消费

这个问题其实换一种问法就是 —— 如何保证消息队列的幂等性?

这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。 

先来说一下为什么会造成重复消费? 

其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因，就是**因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。** 
  

如何解决?这个问题针对业务场景来答分以下几点 

    1. 比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。 
      2. 再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。 
        3. 如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将

### 如何保证消费的可靠性传输

其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据

1. 生产者弄丢数据

   从生产者弄丢数据来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢失消息

   transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。

   然而缺点就是吞吐量下降了。生产上用confirm模式的居多

2. 消息队列弄丢数据

   针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。

   开启持久化磁盘的配置。这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 ACK 信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

3. 消费者弄丢数据

   消费者丢失数据一般是因为采用了自动确认消息模式。这种模式下消费者会自动确认收到消息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。

### 如何保证消息的顺序性

通过某种算法，**将需要保持先后顺序的消息放到同一个消息队列中** (kafka中就是partition,rabbitMq中就是queue)。**然后只用一个消费者去消费该队列**。

有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？

这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。
总之，针对这个问题，我的观点是**保证入队有序就行，出队以后的顺序交给消费者自己去保证**，没有固定套路。





## 消息队列选型

![](https://ws1.sinaimg.cn/large/006iOFs0gy1g1oq1fzif9j30r222x43r.jpg)

