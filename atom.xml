<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dgzd.github.io</id>
    <title>轻尘</title>
    <updated>2020-11-10T05:32:05.670Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dgzd.github.io"/>
    <link rel="self" href="https://dgzd.github.io/atom.xml"/>
    <subtitle>是非在己，毁誉由人，得失不论</subtitle>
    <logo>https://dgzd.github.io/images/avatar.png</logo>
    <icon>https://dgzd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 轻尘</rights>
    <entry>
        <title type="html"><![CDATA[消息队列]]></title>
        <id>https://dgzd.github.io/post/mq/</id>
        <link href="https://dgzd.github.io/post/mq/">
        </link>
        <updated>2019-03-28T01:44:54.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>消息队列简介</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>消息队列简介</p>
</blockquote>
<!-- more -->
<h2 id="什么是消息队列">什么是消息队列</h2>
<p>例如：</p>
<ol>
<li>服务员点菜快，厨师做菜慢，服务员只需要给厨师点菜单即可，然后就可以继续去服务谷歌，不需要等待厨师把菜做完。点菜单就相当于消息，放单子的位置就相当少队列。</li>
<li>业务系统需要发短信，但短信发送模块速度跟不上，业务系统就可以吧发送短信的两个人信息封装为一个消息，放入队列，短信发送模块从队列中获取消息进行处理</li>
</ol>
<p>MQ，是一种跨进程的通信机制，用于上下游传递消息。</p>
<p>在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。</p>
<p>使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<p><a href="https://blog.csdn.net/qq_35152037/article/details/80012961">使用场景</a></p>
<p>消息队列（Message Queue）是一种不同应用程序之间（跨进程）的通信方式。应用程序通过写入和检索出入列队的数据（消息）来通信，而无需通过专用链接来连接它们。</p>
<p>消息发送后可以立即返回，由消息系统来确保信息的可靠传递，消息发布者只管把消息发布到 MQ 中而不管谁来取，消息使用者只管从 MQ 中区消息而不管谁发布的，发布者和使用者都不知道对方的存在</p>
<p><strong>消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。</strong></p>
<p>直接调用通常是用于诸如 <strong>远程过程调用</strong> (Remote Procedure Call. RPC)的技术。</p>
<p>排队指的是应用程序通过队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求，这样天然的就实现了异步的目标。</p>
<h2 id="为什么要使用消息队列">为什么要使用消息队列</h2>
<ul>
<li>解耦、异步、削峰</li>
<li>参考：<a href="https://blog.csdn.net/weixin_40753536/article/details/82383304">为什么要使用 MQ</a>、<a href="https://blog.csdn.net/qq_34288630/article/details/79411529">什么是消息队列</a>、<a href="https://www.liangzl.com/get-article-detail-1992.html">消息队列的功能场景 - 京东技术</a> 、<a href="https://blog.csdn.net/alinshen/article/details/80583214">消息队列会遇到的问题</a></li>
</ul>
<h3 id="解耦">解耦</h3>
<p><strong>传统模式的缺点</strong>：系统间耦合性太强，</p>
<p><strong>中间件模式的优点</strong>：将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而实现解耦。</p>
<figure data-type="image" tabindex="1"><img src="https://ws1.sinaimg.cn/large/006iOFs0gy1g1om5zqkf1j30hi06xmy0.jpg" alt="" loading="lazy"></figure>
<p><strong>业务中的使用场景</strong>：订单系统生成订单，推送到 MQ 后立即返回，结算系统从 MQ 拉取订单并处理</p>
<p>MQ最直接的使用场景就是可以将两个系统进行解耦，比如我们的货款抵扣业务场景，用户生成订单发送MQ后立即返回，结算系统去消费该MQ进行用户账户金额的扣款。这样订单系统只需要关注把订单创建成功，最大可能的提高订单量，并且生成订单后立即返回用户。而结算系统重点关心的是账户金额的扣减，保证账户金额最终一致。这个场景里面还会涉及到重试幂等性问题</p>
<h3 id="异步">异步</h3>
<p><strong>传统模式</strong>：一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p>
<p><strong>中间件模式</strong>：将消息写入消息队列，使非必要的业务逻辑以异步的方式运行，加快响应速度</p>
<p><strong>业务中的使用场景</strong>：订单系统</p>
<p>用户点击 【下单】按钮后的业务逻辑包括：扣减库存、生成相应的订单数据、下单、发送消息通知等</p>
<p>在业务发展的初期，这些逻辑可能放在一起同步执行，但随着业务的整张，，需要提升系统服务的性能，这时候可以将一些不需要立即生效的操作拆分出来异步执行，比如发送消息等。这种场景就可以使用 MQ，在下单的主流程(比如扣减库存、生成相应的单据) 完成之后，发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取 MQ 的消息 ( 或者让 MQ 推送消息 )</p>
<p>上述订单系统中，把下单后发送消息通知存放到 MQ ，通过另外的线程单独调用，就是异步的体现</p>
<h3 id="削峰">削峰</h3>
<p><strong>传统模式</strong>：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p>
<p><strong>中间件模式</strong>：把要处理的请求放入MQ，系统慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<p><strong>业务中的使用场景</strong>：平衡高并发时期的流量</p>
<p>还是以订单系统和结算系统场景为例，如果订单系统通过RPC框架来调用结算系统，在有高峰促销的情况下生成订单的量会非常大，而且由于生成订单的速度也非常快，这样势必会给结算系统造成系统压力，服务器利用率则会偏高，但在不是高峰的时间点订单量比较小，结算系统的服务器利用率则会偏低。</p>
<h2 id="消息队列的优缺点">消息队列的优缺点</h2>
<p>参考：<a href="https://blog.csdn.net/qq_34288630/article/details/79411529">什么是消息队列</a></p>
<h3 id="为什么要分布式消息队列">为什么要分布式消息队列</h3>
<ol>
<li>
<p>多系统协作需要分布式</p>
<p>例如消息队列的数据需要在多个系统之间共享，所以需要提供分布式通信机制，协同机制</p>
</li>
<li>
<p>可靠</p>
<p>消息会被持久化到分布式存储中，这样避免了单台机器存储的消息由于机器问题导致的消息丢失</p>
</li>
<li>
<p>可扩展</p>
<p>分布式消息队列，会随着访问量的增加而方便的增加处理服务器</p>
</li>
</ol>
<h3 id="优点">优点</h3>
<ol>
<li>
<p>提高系统响应速度</p>
<p>使用消息队列，生产者一方把消息往消息队列里一扔，就可以立马返回响应用户，无需等待处理结果</p>
</li>
<li>
<p>保证消息的传递</p>
<p>如果发送消息时接收者不可用，消息队列就会保留消息，直到成功的传递它</p>
</li>
<li>
<p>解耦</p>
<p>只要信息格式不变，即使接收者的接口、位置、或者配置改变，也不会给发送者带来任何改变<br>
消息发送者无需知道消息接收者是谁，使得系统设计更清晰</p>
</li>
</ol>
<h3 id="缺点">缺点</h3>
<p><strong>系统可用性降低</strong></p>
<p>本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</p>
<p><strong>系统复杂性增加</strong></p>
<p>要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
<p>但是，我们该用还是要用的。</p>
<h2 id="常见问题">常见问题</h2>
<p>参考：<a href="https://blog.csdn.net/alinshen/article/details/80583214">消息队列会遇到的问题</a></p>
<h3 id="如何保证消息队列是高可用">如何保证消息队列是高可用</h3>
<p>分析：引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。<br>
回答:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。<br>
以rcoketMQ为例，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。</p>
<p>至于rabbitMQ,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。<br>
要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。</p>
<h3 id="如何保证消息不被重复消费">如何保证消息不被重复消费</h3>
<p>这个问题其实换一种问法就是 —— 如何保证消息队列的幂等性?</p>
<p>这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。</p>
<p>先来说一下为什么会造成重复消费?</p>
<p>其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因，就是<strong>因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。</strong></p>
<p>如何解决?这个问题针对业务场景来答分以下几点</p>
<p>1. 比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。<br>
  2. 再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。<br>
  3. 如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将</p>
<h3 id="如何保证消费的可靠性传输">如何保证消费的可靠性传输</h3>
<p>其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p>
<ol>
<li>
<p>生产者弄丢数据</p>
<p>从生产者弄丢数据来看，RabbitMQ 提供 transaction 和 confirm 模式来确保生产者不丢失消息</p>
<p>transaction机制就是说，发送消息前，开启事务(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。生产上用confirm模式的居多</p>
</li>
<li>
<p>消息队列弄丢数据</p>
<p>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。</p>
<p>开启持久化磁盘的配置。这个持久化配置可以和 confirm 机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个 ACK 信号。这样，如果消息持久化磁盘之前，RabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
</li>
<li>
<p>消费者弄丢数据</p>
<p>消费者丢失数据一般是因为采用了自动确认消息模式。这种模式下消费者会自动确认收到消息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。</p>
</li>
</ol>
<h3 id="如何保证消息的顺序性">如何保证消息的顺序性</h3>
<p>通过某种算法，<strong>将需要保持先后顺序的消息放到同一个消息队列中</strong> (kafka中就是partition,rabbitMq中就是queue)。<strong>然后只用一个消费者去消费该队列</strong>。</p>
<p>有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？</p>
<p>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。<br>
总之，针对这个问题，我的观点是<strong>保证入队有序就行，出队以后的顺序交给消费者自己去保证</strong>，没有固定套路。</p>
<h2 id="消息队列选型">消息队列选型</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker 概述]]></title>
        <id>https://dgzd.github.io/post/docker-gai-shu/</id>
        <link href="https://dgzd.github.io/post/docker-gai-shu/">
        </link>
        <updated>2019-03-14T12:46:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>关于 Docker、Dockerfile、docker-compose 简单概述</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>关于 Docker、Dockerfile、docker-compose 简单概述</p>
</blockquote>
<!-- more -->
<h1 id="docker">Docker</h1>
<h2 id="简介">简介</h2>
<p><strong>Docker 是一种容器技术，作用是用来快速部署服务</strong></p>
<h2 id="docker-解决了什么问题">Docker 解决了什么问题</h2>
<ul>
<li><strong>Docker解决了运行环境和配置问题，方便发布，也就方便做持续集成</strong>。</li>
<li><strong>更轻量的虚拟化，节省了虚拟机的性能损耗</strong></li>
</ul>
<h2 id="docker-应用场景">Docker 应用场景</h2>
<ul>
<li>程序分发，gitlab的安装很恶心吧，所以有人做了gitlab的image</li>
<li>部署发布，可以很好的解决环境和配置问题</li>
<li>PaaS，tsuru、flynn都是基于Docker的，CloudFoundry也要从warden迁移到Docker，不解释</li>
</ul>
<h2 id="容器的启动过程">容器的启动过程</h2>
<ol>
<li>docker client(即：docker终端命令行)会调用docker daemon请求启动一个容器，</li>
<li>docker daemon会向host os(即：linux)请求创建容器</li>
<li>linux会创建一个空的容器（可以简单理解为：一个未安装操作系统的裸机，只有虚拟出来的CPU、内存等硬件资源）</li>
<li>docker daemon请检查本机是否存在docker镜像文件（可以简单理解为操作系统安装光盘），如果有，则加载到容器中（即：光盘插入裸机，准备安装操作系统）</li>
<li>将镜像文件加载到容器中（即：裸机上安装好了操作系统，不再是裸机状态）</li>
</ol>
<h2 id="docker-安装和基础命令">Docker 安装和基础命令</h2>
<ul>
<li>请阅读：<a href="https://ding.gq/Ubuntu%E5%AE%89%E8%A3%85Docker.html#more">Ubuntu 安装及使用 Docker</a></li>
</ul>
<h1 id="dockerfile">Dockerfile</h1>
<h2 id="简介-2">简介</h2>
<p>Dockerfile是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此没一条指令的内容，就是描述该层应当如何构建</p>
<h2 id="命令详解">命令详解</h2>
<h3 id="from">FROM</h3>
<p><strong>指定基础镜像</strong>。必备指令，必须是 Dockerfile 文件的第一条指令</p>
<h3 id="run">RUN</h3>
<p><strong>执行命令</strong>。命令有两种书写格式</p>
<ol>
<li>
<p>shell 格式：<code>RUN</code> 后直接书写命令，就像在 shell 中一样</p>
<pre><code class="language-dockerfile">RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html
</code></pre>
</li>
<li>
<p>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></p>
<pre><code class="language-dockerfile">RUN [&quot;chmod&quot;,&quot;+x&quot;,&quot;start.sh&quot;]
</code></pre>
</li>
</ol>
<h3 id="copy">COPY</h3>
<p><strong>复制文件</strong>。把文件从本机 <code>上下文目录中</code> 复制到容器中，和 <code>RUN</code>指令 一样有两种格式</p>
<pre><code class="language-dockerfile"># 格式1
COPY package.json /usr/src/app/

# 格式2
COPY [&quot;package.json&quot;,&quot;/usr/src/app/&quot;]
</code></pre>
<h3 id="add">ADD</h3>
<p><strong>更高级的复制命令</strong>。和 <code>COPY</code> 的使用格式一致，但在其基础上加了一些功能</p>
<ol>
<li>源路径可以是 URL，Docker 引擎会去下载链接文件放到目标路径，并设置权限为 <code>600</code> ，不如直接使用 <code>RUN</code> 指令配合 <code>wget</code> 或 <code>curl</code>，所以<strong>不推荐使用</strong></li>
<li>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</li>
</ol>
<h3 id="cmd">CMD</h3>
<p><strong>容器启动时运行命令</strong>。命令格式和 <code>RUN</code> 相似，在容器启动是会执行 CMD 所指定的命令</p>
<h3 id="entrypoint">ENTRYPOINT</h3>
<p><strong>指定容器启动时要运行的命令</strong>。目的和 <code>CMD</code> 一样，格式也是 <code>RUN</code> 指令的格式</p>
<p>但当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<pre><code class="language-dockerfile">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;
</code></pre>
<h3 id="env">ENV</h3>
<p><strong>设置环境变量</strong>。在 Dockerfile 文件中设置环境变量，让下面的内容可以引用</p>
<p>无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>例如：</p>
<pre><code class="language-dockerfile">ENV NODE_VERSION 7.2.0

# 可多次引用上面所定义的环境变量
RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; 
</code></pre>
<h3 id="arg">ARG</h3>
<p><strong>构建参数</strong>。效果和 <code>ENV</code> 一样，都是设置环境变量</p>
<p>所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<h3 id="volume">VOLUME</h3>
<p><strong>定义匿名卷</strong>。把容器中的目录挂载出来作为匿名卷，当向容器中写入数据时，不会写入容器中，会写入在本地的卷中</p>
<p>格式：</p>
<pre><code class="language-dockerfile"># 把某一个目录挂载为匿名卷
VOLUME &lt;路径&gt;

#挂载多个目录为匿名卷
VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]
</code></pre>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<pre><code class="language-dockerfile">VOLUME /data
</code></pre>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<pre><code class="language-dockerfile">docker run -d -v mydata:/data xxxx
</code></pre>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="expose">EXPOSE</h3>
<p><strong>暴露端口</strong>。声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</p>
<p>在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code>时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>格式：</p>
<pre><code class="language-dockerfile">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]
</code></pre>
<h3 id="workdir">WORKDIR</h3>
<p><strong>指定工作目录</strong>。指定工作目录（或者称为当前目录）以后，各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<h3 id="user">USER</h3>
<p><strong>指定当前用户</strong>。和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code>则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>格式：</p>
<pre><code class="language-dockerfile">USER &lt;用户名&gt;[:&lt;用户组&gt;]
</code></pre>
<h3 id="healthcheck">HEALTHCHECK</h3>
<p><strong>健康检查</strong>。</p>
<p>格式：</p>
<pre><code class="language-dockerfile">HEALTHCHECK [选项] CMD &lt;命令&gt; # 设置检查容器健康状况的命令

HEALTHCHECK NONE    # 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
</code></pre>
<h3 id="onbuild">ONBUILD</h3>
<p><strong>为他人做嫁衣</strong>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<h1 id="docker-compose">Docker Compose</h1>
<h2 id="简介-3">简介</h2>
<p>Docker Compose 是用来对 docker 容器编排，把所有繁复的 docker 操作全都一条命令，自动化的完成。</p>
<h2 id="安装">安装</h2>
<p>在 Linux 上安装十分简单。从 <a href="https://github.com/docker/compose/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p>
<pre><code class="language-shell">curl -L https://github.com/docker/compose/releases/download/1.24.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose

chmod +x /usr/local/bin/docker-compose
</code></pre>
<h2 id="卸载">卸载</h2>
<p>如果是二进制包安装的，删除二进制包即可</p>
<pre><code class="language-shell">$ sudo rm /usr/local/bin/docker-compose
</code></pre>
<h2 id="compose-模板文件">Compose 模板文件</h2>
<p>MySQL + Nginx + Tomcat 的商城项目</p>
<pre><code class="language-yaml">version: '3'
services:
  tomcat:
    restart: always
    build:
      context: ./bookstore_admin
      dockerfile: tomcat_dockerfile
    image: tomcat
    container_name: tomcat
    ports:
      - 8080:8080
    networks:
      - my_net
    environment:
      TZ: Asia/Shanghai

  nginx:
    restart: always
    image: nginx
    container_name: nginx
    ports:
      - 80:80
    networks:
       - my_net
    volumes:
      - ./conf/nginx.conf:/etc/nginx/nginx.conf
      - ./wwwroot:/usr/share/nginx/wwwroot

  db:
    restart: always
    build:
      context: ./bookstore_db
      dockerfile: Dockerfile
    container_name: mysql
    ports:
      - 3306:3306
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: root
    command:
      --character-set-server=utf8mb4
      --collation-server=utf8mb4_general_ci
      --explicit_defaults_for_timestamp=true
      --lower_case_table_names=1
      --max_allowed_packet=128M
      --sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot;
    volumes:
      - ./data/mysql:/var/lib/mysql
    networks:
      - my_net

networks:
  my_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.1/16

</code></pre>
<h2 id="docker-compose常用命令">Docker Compose常用命令</h2>
<h3 id="build">build</h3>
<p>构建（重新构建）项目中的服务容器。</p>
<pre><code class="language-dockerfile">docker-compose build -f yml文件
</code></pre>
<h3 id="up">up</h3>
<p>构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<pre><code class="language-dockerfile">docker-compose -f yml文件 up 

# -d 以守护进程运行
</code></pre>
<h3 id="down">down</h3>
<p>停止up 命令启动的容器并</p>
<pre><code class="language-dockerfile">docker-compose -f xx.yml down
</code></pre>
<h3 id="logs">logs</h3>
<p>查看服务容器的输出。</p>
<pre><code class="language-dockerfile">docker-compose logs [options] [SERVICE...]
</code></pre>
<h3 id="rm">rm</h3>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<pre><code class="language-dockerfile">docker-compose rm [options] [SERVICE...]

# -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。
# -v  删除容器所挂载的数据卷
</code></pre>
<h3 id="其他命令">其他命令</h3>
<p>请查看 <a href="https://yeasy.gitbooks.io/docker_practice/compose/commands.html">Docker从入门到实战</a></p>
<h1 id="docker-网络设置">Docker 网络设置</h1>
<h2 id="查看-docker-的网卡">查看 docker 的网卡</h2>
<pre><code class="language-dockerfile">$ docker network ls
</code></pre>
<p>Docker安装后，默认会创建下面三种网络类型</p>
<ol>
<li>
<p><strong>bridge：桥接网络</strong></p>
<p>默认情况下启动的 Docker 容器，都是使用 bridge，Docker安装时创建的桥接网络，每次Docker容器重启时，会按照顺序获取对应的IP地址，这个就导致重启下，Docker 的 IP 地址就变了</p>
</li>
<li>
<p><strong>host：主机网络</strong></p>
<p>使用 <code>--network=host</code> ，此时，Docker 容器的网络会附属在主机上，两者是互通的。<br>
例如，在容器中运行一个Web服务，监听8080端口，则主机的8080端口就会自动映射到容器中。</p>
</li>
<li>
<p><strong>none：无指定网络</strong></p>
<p>使用 <code>--network=none</code> ，docker 容器就不会分配局域网的IP</p>
</li>
</ol>
<h2 id="启动-docker时指定网络类型">启动 Docker时指定网络类型</h2>
<p>在 docker 容器启动时，把容器加入指定的网络，使用 <code>--network 网络类型</code></p>
<pre><code class="language-dockerfile">docker run -itd --name test1 --network bridge --ip 172.17.0.10 centos:latest /bin/bash
</code></pre>
<h2 id="创建自定义网络为容器设置固定ip">创建自定义网络：（为容器设置固定IP）</h2>
<p>启动 Docker 容器的时候，使用默认的网络是不支持指派固定IP的，如下</p>
<pre><code class="language-dockerfile">docker run -itd --net bridge --ip 172.17.0.10 centos:latest /bin/bash
</code></pre>
<p>会出现错误提示：</p>
<p><code>docker: Error response from daemon: User specified IP address is supported on user defined networks only.</code></p>
<p><strong>解决方式如下</strong></p>
<ul>
<li>
<p>创建自定义网络</p>
<pre><code class="language-dockerfile">docker network create --subnet=172.18.0.0/16 mynetwork
</code></pre>
</li>
<li>
<p>创建 Docker 容器</p>
<pre><code class="language-dockerfile">docker run -itd --name networkTest1 --net mynetwork --ip 172.18.0.2 centos:latest /bin/bash
</code></pre>
</li>
</ul>
<p>注：当使用 docker-conpose 文件时，可以在 compose 文件中设置容器的网络</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://www.cnblogs.com/neptunemoon/p/6512121.html#toc_2">neptune 破壁人</a></li>
<li><a href="https://www.cnblogs.com/xuezhigu/p/8257129.html">雪之谷</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/image/build.html">Docker从入门到实战</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP的三次握手和四次挥手]]></title>
        <id>https://dgzd.github.io/post/tcp-de-san-ci-wo-shou-he-si-ci-hui-shou/</id>
        <link href="https://dgzd.github.io/post/tcp-de-san-ci-wo-shou-he-si-ci-hui-shou/">
        </link>
        <updated>2019-03-07T12:50:55.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>简述TCP的三次握手和四次挥手。一些个人的简单理</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>简述TCP的三次握手和四次挥手。一些个人的简单理</p>
</blockquote>
<!-- more -->
<h2 id="tcp-的六种标志位">TCP 的六种标志位</h2>
<h3 id="syn-同步标志">SYN 同步标志</h3>
<p>同步序列编号（<strong>Synchronize Sequence Numbers</strong>）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
<h3 id="ack确认标志">ACK：确认标志</h3>
<p>确认编号（<strong>Acknowledgement Number</strong>）在数据通信中，接收站发给发送站的一种传输类<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704">控制字符</a>。表示发来的数据已确认接收无误。</p>
<h3 id="psh-推标志">PSH 推标志</h3>
<p>该标志置位时，接收端不将该<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>进行队列处理，而是尽可能快将数据转由应用处理。在处理 <a href="https://baike.baidu.com/item/telnet">telnet</a> 或 rlogin 等交互模式的连接时，该标志总是置位的。</p>
<h3 id="fin-结束标志">FIN 结束标志</h3>
<p>带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。</p>
<h3 id="urg-紧急标志">URG 紧急标志</h3>
<p>指镇优先（<strong>Urgent Pointer</strong>）</p>
<h3 id="rst-复位标志">RST 复位标志</h3>
<p>用于复位相应的TCP连接。</p>
<h2 id="tcp-三次握手">TCP 三次握手</h2>
<figure data-type="image" tabindex="1"><img src="https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukssf46mj30ed08gwei.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>SYN ( Synchronize Sequence Numbers )：同步序列号，用于建立连接</p>
</blockquote>
<blockquote>
<p>ACK ( Acknowledgement )：确认序列号有效</p>
</blockquote>
<blockquote>
<p>seq ( Sequence number )： 顺序号码</p>
</blockquote>
<blockquote>
<p>ack ( Acknowledge number )：确认号码</p>
</blockquote>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<h2 id="为什么要三次握手">为什么要三次握手</h2>
<p>在《计算机网络》一书中其中有提到，三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。</p>
<p>问题的本质是，信道是不可靠的，但是我们要建立可靠的连接发送可靠的数据，也就是数据传输是需要可靠的。在这个时候三次握手是一个理论上的最小值，并不是说是tcp协议要求的，而是为了满足在不可靠的信道上传输可靠的数据所要求的。</p>
<p>我们再来考虑，如果不是三次握手会出现什么情况呢：</p>
<p>假设有A和B两端要进行通信，</p>
<ol>
<li>
<p>第一次：首先A发送一个(SYN)到B，意思是A要和B建立连接进行通信；</p>
<blockquote>
<p>如果是只有一次握手的话，这样肯定是不行的，A压根都不知道B是不是收到了这个请求。TCP协议变的与面向无连接的UDP 协议无异</p>
</blockquote>
</li>
<li>
<p>第二次：B收到A要建立连接的请求之后，发送一个确认(SYN+ACK)给A，意思是收到A的消息了，B这里也是通的，表示可以建立连接；</p>
<blockquote>
<p>如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。也可能 B 收到的是 A 发送的失效了的报文（A发送后，由于某种原因没收到回应，报文被作废），B 建立了连接，A 却一直没有发送数据，占用着 B 的连接资源</p>
</blockquote>
</li>
<li>
<p>第三次：A如果收到了B的确认消息之后，再发出一个确认(ACK)消息，意思是告诉B，这边是通的，然后A和B就可以建立连接相互通信了；</p>
<blockquote>
<p>这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。</p>
</blockquote>
</li>
<li>
<p>第四次：这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。</p>
<blockquote>
<p>如果第二个报文段B发出的(SYN+ACK)分别发送的话，也是可以理解为四次，但是被优化了，一起发送了。</p>
</blockquote>
</li>
</ol>
<h2 id="tcp-四次挥手">TCP 四次挥手</h2>
<p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://ws1.sinaimg.cn/large/006iOFs0gy1g0ukuxutooj30e308zjrf.jpg" alt="" loading="lazy"></figure>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p>
<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
<p>被动关闭具体流程：</p>
<figure data-type="image" tabindex="3"><img src="https://ws1.sinaimg.cn/large/006iOFs0gy1g0unpy9lz2j30dz05b0sp.jpg" alt="" loading="lazy"></figure>
<h2 id="为什么要四次挥手">为什么要四次挥手</h2>
<p>本质的原因是tcp是全双工的，要实现可靠的连接关闭，A发出结束报文FIN，收到B确认后A知道自己没有数据需要发送了，B知道A不再发送数据了，自己也不会接收数据了，但是此时A还是可以接收数据，B也可以发送数据；当B发出FIN报文的时候此时两边才会真正的断开连接，读写分开。</p>
<p>因为TCP有个半关闭状态，假设A.B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭。然后B还要发给A连接释放报文，然后A发确认，所以是4次。</p>
<p>在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是<strong>全双工模式</strong>，<strong>接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。</strong></p>
<p><strong>四次挥手牵扯到的状态装换：</strong></p>
<p>**FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；</p>
<p>**FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；</p>
<p>**TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；</p>
<p>**CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；</p>
<p>**CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；</p>
<p>**LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；</p>
<p>**CLOSED ** 这个状态表示连接已经断开。</p>
<figure data-type="image" tabindex="4"><img src="https://ws1.sinaimg.cn/large/006iOFs0gy1g0uowyfpy6j30k00mbq3x.jpg" alt="" loading="lazy"></figure>
<h2 id="参考">参考：</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_34386891/article/details/80515912">CSDN</a></li>
<li><a href="https://www.jianshu.com/p/e7f45779008a">简书</a></li>
<li><a href="https://blog.csdn.net/sdgihshdv/article/details/79503274">CSDN</a></li>
<li><a href="https://blog.csdn.net/zzhongcy/article/details/38851271">CSDN</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装及使用Docker]]></title>
        <id>https://dgzd.github.io/post/ubuntu-docker/</id>
        <link href="https://dgzd.github.io/post/ubuntu-docker/">
        </link>
        <updated>2019-03-01T07:06:59.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu 下安装及使用 Docker</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu 下安装及使用 Docker</p>
</blockquote>
<!-- more -->
<h2 id="docker">Docker</h2>
<h3 id="概念">概念</h3>
<p>Docker 是将发布程序运行所需要的环境打包到一起，自动化运行的容器；是一个开源项目，支持大部分的 Linux 发行版，操作系统层以上的虚拟化技术。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<h3 id="优点">优点</h3>
<p>与传统的虚拟化方式相比：</p>
<ul>
<li>更高效的利用系统资源</li>
<li>更快的启动速度</li>
<li>一致的运行环境</li>
<li>持续交互和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ul>
<h3 id="组成">组成</h3>
<ul>
<li>Docker Client：通过 Api 访问 Docker Daemon 管理 Docker 镜像</li>
<li>Docker Daemon：守护进程，负责 Docker 镜像的创建、删除、启动、停止等服务</li>
<li>Docker Image：镜像，一张 “只读” 的系统 CD</li>
<li>Docker Container：Docker 的容器，Docker Images 运行实例</li>
<li>Docker Registry：Docker Images 的仓库，Docker Hub：https://www.dockerhub.com</li>
</ul>
<h2 id="ubuntu-安装-docker">Ubuntu 安装 Docker</h2>
<p>参考：<a href="https://www.jianshu.com/p/07e405c01880">简书</a></p>
<h3 id="方式一">方式一</h3>
<ul>
<li>
<p>使用官方脚本自动安装</p>
<pre><code class="language-shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
</code></pre>
</li>
</ul>
<h3 id="方式二">方式二</h3>
<ul>
<li>
<p>添加HTTPS协议，允许apt从HTTPS安装软件包</p>
<pre><code class="language-shell">sudo apt-get install  apt-transport-https  ca-certificates curl  software-properties-common

</code></pre>
</li>
<li>
<p>添加 Docker 公共密钥</p>
<pre><code class="language-shell"># docker 官方源
curl -fsSL  https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add

# docker 中科大源，添加中科大即可
curl -fsSL  https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

</code></pre>
</li>
<li>
<p>设置版本库类型（Ubuntu18.04对应版本**“bionic“”**），软件版本包括三种：stable、edge、test</p>
<pre><code class="language-shell"># Docker 官方
sudo add-apt-repository &quot;deb [arch=amd64]  https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 


# Docker 中科大
sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 

</code></pre>
</li>
<li>
<p>安装 Docker CE</p>
<pre><code class="language-shell"># 更新 apt-get 源
sudo apt-get update

# 安装
sudo apt-get install docker-ce
</code></pre>
</li>
</ul>
<h2 id="docker-常用命令">Docker 常用命令</h2>
<p>参考：<a href="https://blog.csdn.net/hcljava/article/details/78588623">CSDN</a></p>
<h3 id="添加用户到-docker-用户组">添加用户到 docker 用户组</h3>
<ol>
<li>
<p>创建 docker 用户组</p>
<pre><code class="language-shell">sudo groupadd docker
</code></pre>
</li>
<li>
<p>把需要的用户加入 docker 用户组</p>
<pre><code class="language-shell">sudo usermod -aG docker ${USER}

sudo gpasswd -a dylan docker
</code></pre>
</li>
<li>
<p>重启 docker 服务</p>
<pre><code class="language-shell">sudo systemctl restart docker

sudo service docker restart
</code></pre>
</li>
<li>
<p>切换用户后重新登录此普通用户，才能生效</p>
</li>
</ol>
<h3 id="docker-基本">Docker 基本</h3>
<ul>
<li>
<p>启动 docker</p>
<pre><code class="language-shell">systemctl start docker
</code></pre>
</li>
<li>
<p>查看 docker 版本</p>
<pre><code class="language-shell"># 简单查看版本
docker -v  [--version]

# 查看详细版本
docker version
</code></pre>
</li>
<li>
<p>显示 docker 系统的信息</p>
<pre><code>docker info
</code></pre>
</li>
</ul>
<h3 id="操纵-docker-镜像">操纵 Docker 镜像</h3>
<ul>
<li>
<p>检索 image</p>
<pre><code>docker search image-name
</code></pre>
</li>
<li>
<p>下载 image</p>
<pre><code>docker pull image-name
</code></pre>
</li>
<li>
<p>列出镜像列表</p>
<pre><code>docker images
</code></pre>
</li>
<li>
<p>删除一个或多个 images 镜像（删除时需要先删除容器，使用 <code>docker ps -a</code> 查看运行的容器，使用 <code>docker rm 容器id</code> 删除容器） ——参考：<a href="https://blog.csdn.net/flydreamzhll/article/details/80900509">CSDN</a></p>
<pre><code>docker rmi image-name
</code></pre>
</li>
<li>
<p>显示一个镜像的历史</p>
<pre><code>docker history image-name
</code></pre>
</li>
<li>
<p>通过容器创建镜像</p>
<p>从已经创建的容器中更新镜像，并且提交这个镜像 *使用 Dockerfile 指令来创建一个新的镜像 下面通过已存在的容器创建一个新的镜像</p>
<pre><code>docker commit -m=&quot;First Image&quot; -a=&quot;keke&quot; 7a15f99695c0 keke/unbantu:17.10.0
</code></pre>
<p>参数说明：</p>
<pre><code>-m  提交的描述信息
-a  指定镜像作者
7a15f99695c0 记住这个是容器id，不是镜像id
keke/unbantu:17.10.0 创建的目标镜像名
</code></pre>
</li>
<li>
<p>镜像发布</p>
<ol>
<li>
<p>在<a href="https://www.docker.com/">Docker</a> 注册账户，发布的镜像都在<a href="https://cloud.docker.com/repository/list">这个页面里</a>展示</p>
</li>
<li>
<p>将上面做的镜像unbantu，起个新的名字unbantu-test</p>
<pre><code>docker tag keke/unbantu:17.10.0 keke/unbantu-test:lastest
</code></pre>
</li>
<li>
<p>登录 docker</p>
<pre><code>docker login
</code></pre>
</li>
<li>
<p>上传 Ubuntu 镜像</p>
<pre><code>docker push keke/unbantu-test:lastest
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="启动容器">启动容器</h3>
<p>Docker 容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<ul>
<li>
<p>在容器中安装新的程序</p>
<pre><code>docker run image-name apt-get install -y -name
</code></pre>
<p>注意：在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失.</p>
</li>
<li>
<p>在容器中运行库 echo 命令</p>
<pre><code>docker run image-name echo &quot;hello word&quot;
</code></pre>
</li>
<li>
<p>交互式进入容器中</p>
<pre><code>docker run -i -t image_name /bin/bash
</code></pre>
</li>
</ul>
<h3 id="查看容器">查看容器</h3>
<ul>
<li>
<p>列出当前所有正在运行的 container</p>
<pre><code>docker ps
</code></pre>
</li>
<li>
<p>列出所有的 container</p>
<pre><code>docker ps -a
</code></pre>
</li>
<li>
<p>列出最近一次启动的 container</p>
<pre><code>docker ps -l
</code></pre>
</li>
</ul>
<h3 id="操纵容器">操纵容器</h3>
<ul>
<li>
<p>保存对容器的修改</p>
<p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器</p>
<pre><code>docker commit ID new-image-name
</code></pre>
<p>选项：<code>-a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message</code></p>
</li>
<li>
<p>删除所有容器</p>
<pre><code>docker rm `docker ps -a -q`
</code></pre>
</li>
<li>
<p>删除单个容器</p>
<pre><code>docker rm Name/ID
</code></pre>
<p>-f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container</p>
</li>
<li>
<p>停止、启动、杀死一个容器</p>
<pre><code>docker stop Name/ID  

docker start Name/ID  

docker kill Name/ID
</code></pre>
</li>
<li>
<p>从一个容器中取出日志</p>
<pre><code>docker logs Name/ID
</code></pre>
<p>-f, --follow=false Follow log output; -t, --timestamps=false Show timestamps</p>
</li>
<li>
<p>列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的</p>
<pre><code>docker diff Name/ID
</code></pre>
</li>
<li>
<p>显示一个运行的容器里面的进程信息</p>
<pre><code>docker top Name/ID
</code></pre>
</li>
<li>
<p>从容器里面拷贝文件/目录到本地一个路径</p>
<pre><code>docker cp Name:/container-path to-path  

docker cp ID:/container-path to-path
</code></pre>
</li>
<li>
<p>.重启一个正在运行的容器</p>
<p>-t, --time=10 Number of seconds to try to stop for before killing the container, Default=10</p>
<pre><code>docker restart Name/ID
</code></pre>
</li>
<li>
<p>在容器外，使用容器执行命令</p>
<pre><code>docker exec 容器名 命令

docker exec -i -t  mynginx /bin/bash
</code></pre>
</li>
<li>
<p>附加到一个运行的容器上面</p>
<pre><code>docker attach ID #重新启动并运行一个交互式会话shell
</code></pre>
</li>
</ul>
<h3 id="构建镜像">构建镜像</h3>
<h4 id="一-通过-commit-命令提交容器为镜像">一、通过 commit 命令提交容器为镜像</h4>
<p>在容器中设置好我们所需要的配置，使用 <code>docker commit</code> 来提交容器作为镜像</p>
<pre><code>docker commit -m=&quot;A new custom image&quot; --author=&quot;Bourbon Tian&quot; b437ffe4d630 test/apache2:webserver
</code></pre>
<p>选项：</p>
<ul>
<li><code>-m</code> ：用来指定创建镜像要提交的消息</li>
<li><code>--author</code> ：用来列出该镜像的作者信息</li>
</ul>
<h4 id="二-通过-dockerfile-文件构建镜像">二、通过 Dockerfile 文件构建镜像</h4>
<ol>
<li>
<p>创建文件夹并在其中创建 Dockerfile 文件</p>
</li>
<li>
<p>在 Dockerfile 中写入镜像 有关指令</p>
</li>
<li>
<p>运行 <code>docker build</code> 构建镜像</p>
<pre><code>docker build -t dylan/ubuntu:v1 . 
</code></pre>
<p>选项：<code>-t</code> ：tag 、<code>-f</code>：dockerfile 文件位置</p>
<p>​</p>
</li>
</ol>
<h3 id="保存和加载镜像">保存和加载镜像</h3>
<ul>
<li>
<p>保存镜像到一个 tar 包； -o --output=&quot;&quot; Write to an file</p>
<pre><code>docker save image-name -o file-path

# Ubuntu 上保存nginx 到 tmp 下
docker save nginx:latest &gt; /tmp/nginx.tar
</code></pre>
</li>
<li>
<p>加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file</p>
<pre><code>docker load -i file-path
</code></pre>
</li>
<li>
<p>从 A 机器拷贝到 B 机器</p>
<pre><code>docker load &lt; /home/keke/main.tar
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装MySql]]></title>
        <id>https://dgzd.github.io/post/ubuntu-mysql/</id>
        <link href="https://dgzd.github.io/post/ubuntu-mysql/">
        </link>
        <updated>2019-02-28T11:54:51.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu安装MySql</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu安装MySql</p>
</blockquote>
<!-- more -->
<h1 id="ubuntu-安装-mysql">Ubuntu 安装 MySQL</h1>
<h2 id="安装">安装</h2>
<ul>
<li>
<p>修改 apt 源（已修改的可忽略）</p>
<ol>
<li>
<p>备份原文件</p>
<pre><code class="language-shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
</code></pre>
</li>
<li>
<p>编辑源列表文件</p>
<pre><code class="language-shell">sudo vim /etc/apt/sources.list
</code></pre>
</li>
<li>
<p>删除原来的文件内容，添加下列源</p>
<pre><code class="language-list">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
</code></pre>
</li>
<li>
<p>更新 apt-get 数据源</p>
<pre><code class="language-shell">sudo apt-get update
</code></pre>
</li>
</ol>
</li>
<li>
<p>使用 apt-get 安装 <code>mysql-server</code></p>
<pre><code class="language-shell">apt-get install mysql-server
</code></pre>
</li>
</ul>
<h2 id="配置">配置</h2>
<ul>
<li>
<p>运行安全脚本</p>
<pre><code class="language-shell">mysql_secure_installation
</code></pre>
<p>这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。</p>
</li>
<li>
<p>查看 MySQL 状态</p>
<pre><code class="language-shell">systemctl status mysql.service
</code></pre>
</li>
<li>
<p>查看 MySQL 版本</p>
<pre><code class="language-shell">mysqladmin -p -u root version
</code></pre>
</li>
<li>
<p>配置远程访问</p>
<pre><code class="language-shell"># 修改配置文件
vim /etc/mysql/mysql.conf.d/mysqld.cnf

# 注释掉绑定的 IP地址
bind-address = 127.0.0.1

# 重启 MySQL
service mysql restart

</code></pre>
</li>
<li>
<p>登录 MySQL，并在其中操作</p>
<pre><code class="language-mysql">-- 登录
mysql -u root -p

-- 设置密码安全策略
set global validate_password_policy=0;
-- 设置密码最少长度
set global validate_password_length=1;

-- 允许root用户/密码“123456”,在localhost发起的访问
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY '123456' WITH GRANT OPTION;
-- 允许root用户/密码“123456”,在127.0.0.1发起的访问
GRANT ALL PRIVILEGES ON *.* TO 'root'@'127.0.0.1' IDENTIFIED BY '123456' WITH GRANT OPTION;
-- 允许root用户/密码“123456”,在局域网所以ip发起的访问
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;

-- 刷新权限
FLUSH PRIVILEGES;
</code></pre>
</li>
<li>
<p>修改 <code>mysqld.cnf</code> 配置文件</p>
<pre><code class="language-shell"># 进入文件
vi /etc/mysql/mysql.conf.d/mysqld.cnf
</code></pre>
<p>在 <code>[mysqld]</code> 节点上增加一个节点</p>
<pre><code>[client]
default-character-set=utf8
</code></pre>
<p>在 <code>[mysqld]</code> 节点底部增加如下配置</p>
<pre><code>skip-grant-tables
default-storage-engine=INNODB
character-set-server=utf8
collation-server=utf8_general_ci
lower-case-table-names = 1
</code></pre>
</li>
</ul>
<p>​	注：出现拒绝访问root用户的解决方案，添加上述 <code>skip-grant-tables</code> 配置</p>
<p>​      参考：<a href="https://blog.csdn.net/qq_36675754/article/details/81381341">CSDN</a></p>
<p>​      配置文件详情：<a href="https://blog.csdn.net/lienfeng6/article/details/78140404">mysql配置文件详情</a></p>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>
<p>启动</p>
<pre><code class="language-shell"># 启动方式1 
service mysql start

# 启动方式2
systemctl start mysql.service
</code></pre>
</li>
<li>
<p>停止</p>
<pre><code class="language-shell">service mysql stop
</code></pre>
</li>
<li>
<p>重启</p>
<pre><code class="language-shell">service mysql restart
</code></pre>
</li>
<li>
<p>查看 MySQL 状态</p>
<pre><code class="language-shell">systemctl status mysql.service
</code></pre>
</li>
</ul>
<h2 id="部署应用到生产环境">部署应用到生产环境</h2>
<ul>
<li>
<p>导入数据库</p>
<p>使用 MySQL 工具导入即可</p>
</li>
<li>
<p>设置 Tomcat 远程访问密码</p>
<pre><code class="language-xml">1. 修改 Tomcat 下的 conf/tomcat-users.xml
&lt;tomcat-users&gt; 
&lt;role rolename=&quot;manager-gui&quot;/&gt; 
&lt;role rolename=&quot;admin-gui&quot;/&gt; 
&lt;role rolename=&quot;manager-script&quot;/&gt; 
&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager-gui,admin-gui,manager-script&quot;/&gt; 
&lt;/tomcat-users&gt; 

2. 同时还需要修改，如无新建conf/Catalina/localhost/manager.xml 内容如下：

&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot;
         docBase=&quot;${catalina.home}/webapps/manager&quot;&gt;
    &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt;
&lt;/Context&gt;
</code></pre>
</li>
<li>
<p>部署 WEB 项目</p>
<ol>
<li>
<p>手动发布</p>
<p>访问地址：<code>http://10.3.133.33:8080/manager</code> 页面，利用 Tomcat 进行发布</p>
</li>
<li>
<p>Maven 插件发布</p>
<p>在项目最顶层添加插件，运行插件即可</p>
<pre><code class="language-xml"> &lt;build&gt;
        &lt;plugins&gt;
            &lt;!-- tomcat插件 --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;url&gt;http://10.3.50.119:8080/manager/text&lt;/url&gt;
                    &lt;username&gt;admin&lt;/username&gt;
                    &lt;password&gt;admin&lt;/password&gt;
                    &lt;update&gt;true&lt;/update&gt;
                    &lt;path&gt;/test&lt;/path&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu安装Tomcat]]></title>
        <id>https://dgzd.github.io/post/ubuntu-tomcat/</id>
        <link href="https://dgzd.github.io/post/ubuntu-tomcat/">
        </link>
        <updated>2019-02-28T11:54:43.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu 安装 Tomcat</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu 安装 Tomcat</p>
</blockquote>
<!-- more -->
<h2 id="ubuntu-安装-tomct">Ubuntu 安装 Tomct</h2>
<ol>
<li>
<p>官网下载 Linux 对应的安装包</p>
<ul>
<li><a href="http://tomcat.apache.org/download-80.cgi">官网</a></li>
</ul>
</li>
<li>
<p>上传并解压缩，移动到 <code>/usr/local/tomcat8</code>，设置所有者</p>
<pre><code class="language-shell"># 解压
tar -zxvf apache-tomcat-8.5.23.tar.gz
# 重命名
mv apache-tomcat-8.5.23 tomcat
# 移动目录
mv tomcat /usr/local/tomcat8/
</code></pre>
</li>
<li>
<p>Tomcat常用命令</p>
<pre><code class="language-shell"># 启动
/usr/local/tomcat/bin/startup.sh

# 停止
/usr/local/tomcat/bin/shutdown.sh
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu必要设置]]></title>
        <id>https://dgzd.github.io/post/ubuntu-bi-yao-she-zhi/</id>
        <link href="https://dgzd.github.io/post/ubuntu-bi-yao-she-zhi/">
        </link>
        <updated>2019-02-28T08:54:47.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu系统对网卡设置静态地址和设置时区</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>Ubuntu系统对网卡设置静态地址和设置时区</p>
</blockquote>
<!-- more -->
<h2 id="ubuntu设置网卡静态地址">Ubuntu设置网卡静态地址</h2>
<ol>
<li>
<p>进入网卡配置文件</p>
<pre><code class="language-shell">vim /etc/netplan/50-cloud-init.yaml
</code></pre>
</li>
<li>
<p>修改配置如下</p>
<pre><code class="language-shell">network:
    ethernets:
        enp0s3:
            addresses: [10.3.133.33/24]
            gateway4: 10.3.133.1
            dhcp4: no
            dhcp6: no
            nameservers:
                addresses: [10.3.133.1,114.114.114.114]
    version: 2         
</code></pre>
</li>
<li>
<p>使配置生效</p>
<pre><code class="language-shell">netplan apply
</code></pre>
</li>
</ol>
<h2 id="ubuntu设置时区">Ubuntu设置时区</h2>
<ol>
<li>
<p>运行如下命令选择时区<br>
亚洲 -&gt; 中国 -&gt; 北京</p>
<pre><code class="language-shell">sudo tzselect
</code></pre>
</li>
<li>
<p>创建时区软连接</p>
<pre><code class="language-shell">sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
</li>
</ol>
<h2 id="ubuntu-设置-ssh-可通过-root-用户登录">Ubuntu 设置 ssh 可通过 Root 用户登录</h2>
<p>当我们使用远程连接工具通过 root 用户登录 Ubuntu 时，会出现 <code>Permission denied,please try again</code> 并一直让我们输入密码，出现这中情况，是因为我们系统默认禁止 root 用户 ssh 登录。解决办法如下</p>
<ul>
<li>参考：<a href="https://blog.csdn.net/u010867294/article/details/78109551">CSDN</a></li>
</ul>
<ol>
<li>
<p>普通用户登录，并切换为 root 用户</p>
</li>
<li>
<p>更改 <code>sshd_config</code> 文件</p>
<pre><code class="language-shell">vim /etc/ssh/sshd_config
</code></pre>
<p>找到 **#Authentication:**下的 <code>PermitRootLogin without-password</code> 如果是没注释的则注释掉。并在下面加上一行</p>
<pre><code class="language-shell">PermitRootLogin yes
</code></pre>
<p>找错 <strong>Authentication</strong>下的 <code>PasswordAuthentication</code> 开启密码验证</p>
<pre><code class="language-shell"># Authentication:
 PasswordAuthentication yes //默认为no，改为yes开启密码登陆
</code></pre>
</li>
<li>
<p>重启 ssh 服务，使配置生效</p>
<pre><code class="language-shell">/etc/init.d/ssh restart
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软路由的CPU]]></title>
        <id>https://dgzd.github.io/post/nas/</id>
        <link href="https://dgzd.github.io/post/nas/">
        </link>
        <updated>2018-09-19T13:49:16.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>今天无意中在 chiphell 看到一篇帖子，有一张常用软路由的CPU图，这里和大家分享一下。</p>
</blockquote>
<!-- more -->
<hr>
<figure data-type="image" tabindex="1"><img src="https://static.chiphell.com/forum/201808/06/191741r919cyy9n55b7ppg.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[运维笔记]]></title>
        <id>https://dgzd.github.io/post/yun-wei-bi-ji/</id>
        <link href="https://dgzd.github.io/post/yun-wei-bi-ji/">
        </link>
        <updated>2018-08-31T05:01:01.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="运维常用命令">运维常用命令</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="运维常用命令">运维常用命令</h2>
<!-- more -->
<ul>
<li>
<p>Linux命令详解：<code>man.linuxde.net/命令名</code></p>
</li>
<li>
<p>ifconfig</p>
<ul>
<li>
<p>查看网络地址：<code># ifconfig</code></p>
</li>
<li>
<p>网卡配置文件：<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
</li>
<li>
<p>网卡配置详细内容</p>
<pre><code>DEVICE=eth0 网卡的名字

HWADDR=00:0c:29:90:89:d9 HWADDR HardWare Address 硬件地址 MAC地址

TYPE=Ethernet 网络类型 以太网

UUID=ae779ae6-044d-43d5-a33b-48c89e8de10e #UUID 做到系统中独一无二。

ONBOOT=yes BOOT ON ? 在开机或重启网卡的时候是否启动网卡

NM_CONTROLLED=yes 是否受network程序管理

BOOTPROTO=none 网卡是如何获取到ip地址 网卡获取ip地址的方式

　　a. dhcp 自动获取ip地址

　　b. none 固定的ip地址

　　c. static 固定的ip地址

IPADDR=10.0.0.100 IPADDR ip地址

NETMASK=255.255.255.0 子网掩码 决定这个局域网中最多有多少台机器

GATEWAY=10.0.0.2 网关 整个大楼的大门

USERCTL=no 普通用户是否能控制网卡

/etc/resolv.conf 配置DNS 网卡配置文件的DNS优先于/etc/resolv.conf

DNS 域名解析器 阿里的域名解析器：223.5.5.5 223.6.6.6

</code></pre>
</li>
<li>
<p>重启网卡：<code># /etc/init.d/network restart</code></p>
</li>
</ul>
</li>
<li>
<p>nameserver</p>
<ul>
<li>配置DNS服务器：<code># nameserver 8.8.8.8</code></li>
</ul>
</li>
<li>
<p>du</p>
<ul>
<li>显示文件的大小：<code># du -h 文件路径</code></li>
<li>-h：以易读的方式显示</li>
</ul>
</li>
<li>
<p>ps -ef</p>
<ul>
<li>
<p>当前系统的进程状态：<code># ps -ef</code></p>
</li>
<li>
<p>选项</p>
<pre><code class="language-shell">-e：显示所有程序，与‘A’效果相同
-f：显示UID,PPIP,C与STIME栏位。
</code></pre>
</li>
<li>
<p>搭配 <code>grep</code> 可以过滤所需要查看的进程：<code># ps -ef | grep vim</code></p>
</li>
<li>
<p>搭配 <code>kill</code> 可结束进程：<code>kill PID/进程名</code></p>
</li>
</ul>
</li>
<li>
<p>top</p>
<ul>
<li>
<p>实时查看系统的运行情况：<code># top</code></p>
</li>
<li>
<p>可按c、m等键按照CPU、Memory排序</p>
</li>
<li>
<p>按q退出</p>
</li>
</ul>
</li>
<li>
<p>df -th</p>
<ul>
<li>
<p>显示磁盘分区上可使用的磁盘空间：<code># df -th</code></p>
</li>
<li>
<p>选项</p>
<pre><code class="language-shell">-t (--type)仅显示指定文件系统类型的磁盘信息
-h 以可读性较高的方式显示
</code></pre>
</li>
</ul>
</li>
<li>
<p>mount</p>
<ul>
<li>加载文件系统到指定的加载点：<code># mount /dev/cdrom /mnt/cdrom</code></li>
<li><code>/dev</code> 目录下存放了外部设备</li>
<li><code>/mnt</code> 目录下可用于挂载外部设备</li>
</ul>
</li>
<li>
<p>tar</p>
<ul>
<li>
<p>归档，压缩，解压缩等</p>
</li>
<li>
<p>选项：</p>
<pre><code class="language-shell">-x    解压缩文件
-c    创建压缩文件(create)
-z	  gzip
-j	  bzip2
-v	  显示过程
-t    查看压缩包内文件
-f    (file)必备选项
</code></pre>
</li>
<li>
<p>查看<code>.tar.gz</code>文件：<code># tar -ztvf log.tar.gz</code></p>
</li>
<li>
<p>解压<code>.tar.gz</code>文件：<code># tar -zxvf /opt/soft/test/log.tar.gz</code></p>
</li>
<li>
<p>将文件打包：</p>
<pre><code class="language-shell"># tar -cvf log.tar log2012.log       仅打包，不压缩，最后一列是操作对象，也即是要打包的文件
# tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
# tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 
</code></pre>
</li>
</ul>
</li>
<li>
<p>rpm</p>
<ul>
<li>从rpm软件包安装软件：<code># rpm -ivh 软件包路径</code></li>
<li>列出所安装的rpm软件：<code># rpm -qa</code></li>
<li>一个rpm包中的文件安装到那里去了：<code>rpm -ql rpm包名</code></li>
</ul>
</li>
<li></li>
</ul>
<hr>
<h2 id="ntp-时间服务器的配置">NTP 时间服务器的配置</h2>
<ul>
<li>可参考：<a href="https://www.cnblogs.com/jczhu/p/5851268.html">火之晨曦</a></li>
</ul>
<ol>
<li>
<p>安装NTP服务</p>
<pre><code class="language-shell"># yum install ntp ntpdate
</code></pre>
</li>
<li>
<p>修改配置文件</p>
<pre><code class="language-shell"># vim /etc/ntp.conf
</code></pre>
<p>把下列配置替换原有配置文件</p>
<pre><code>driftfile /var/lib/ntp/drift
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
restrict 127.0.0.1
restrict -6 ::1
server 127.127.1.0		#local clock
server pool.ntp.org		#local clock
fudge 127.127.1.0 stratum 10
includefile /etc/ntp/crypto/pw
keys /etc/ntp/keys
</code></pre>
</li>
<li>
<p>查看NTP服务器</p>
<pre><code class="language-shell"># ntpq -p
</code></pre>
</li>
</ol>
<hr>
<h2 id="dhcp-服务器">DHCP 服务器</h2>
<ul>
<li>可参考：</li>
</ul>
<ol>
<li>
<p>安装DHCP服务</p>
<pre><code># yum install dhcp dhcp-devel -y
</code></pre>
</li>
<li>
<p>修改配置文件</p>
<pre><code class="language-shell"># vim /etc/dhcp.conf
</code></pre>
<p>配置：</p>
<pre><code>
</code></pre>
</li>
</ol>
<hr>
<h2 id="samba-服务器">Samba 服务器</h2>
<ul>
<li>可参考：<a href="https://www.cnblogs.com/hxgoto/p/7071175.html">一如莱戈、</a></li>
</ul>
<ol>
<li>
<p>安装samba服务</p>
<pre><code class="language-shell"># yum install -y samba
</code></pre>
</li>
</ol>
<ul>
<li>
<p>安装成功后，系统会生成服务的配置文件和一些命令工具</p>
<ul>
<li>
<p><code>/etc/samba/smb.conf</code>  //是samba服务的主配置文件</p>
</li>
<li>
<p><code>/etc/init.d/smb</code>             //是samba的启动/关闭文件</p>
</li>
<li>
<p>查看开机启动情况：<code># service smb status</code></p>
</li>
<li>
<p>启动服务：<code># service smb start</code></p>
</li>
<li>
<p>设置开机启动：</p>
<pre><code class="language-shell"># chkconfig  --level 35 smb on      // 设置开机启动
# chkconfig --list smb				、、 查看0-6的状态，smb服务启动或关闭
</code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>配置</p>
<pre><code class="language-shell"># vim /etc/samba/smb.conf

配置：

[global]　　　　　　　　　　　　　　//设置samba服务整体环境

workgroup = WORKGROUP　　　　　  //设置工作组名称
server string = Samba Server Version %v     //服务器说明

[dingLinux]　　　　　　　//共享目录的名称

comment = Public stuff　　　//注释说明　
path = /usr/local/laig　　　//共享目录的路径
public = yes　　　 　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)
writeable = yes　　　　　//是yes/否no不以只读方式共享当与read only发生冲突时，无视read only
browseable = yes　      //是yes/否no在浏览资源中显示共享目录，若为否则必须指定共享路径才能存取
guest ok = yes　　　　　　//是yes/否no公开共享，若为否则进行身份验证(只有当security = share 时此项才起作用)
</code></pre>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>防火墙要关闭： <code># service iptables stop</code></p>
</li>
<li>
<p>selinux要设置成disabled，路径是：<code>/etc/sysconfig/selinux</code></p>
</li>
<li>
<p>注意共享目录的权限设置</p>
</li>
<li>
<p>要设置成不需要用户名密码直接访问，需要修改配置文件，将<code>security</code>设置成<code>security = share</code></p>
</li>
<li>
<p>修改配置后要重启服务：<code># service smb restart</code></p>
</li>
</ul>
</li>
<li>
<p>访问共享文件夹</p>
<ul>
<li>在windows中打开文件资源管理器输入 <code>\\192.168.1.194</code> 进行访问，ip地址根据自己的服务器地址来输入</li>
</ul>
</li>
</ol>
<hr>
<h2 id="apache服务器安装">Apache服务器安装</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[系统引导修复]]></title>
        <id>https://dgzd.github.io/post/xi-tong-yin-dao-xiu-fu/</id>
        <link href="https://dgzd.github.io/post/xi-tong-yin-dao-xiu-fu/">
        </link>
        <updated>2018-08-04T11:41:44.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>这两天折腾双系统把Windows10的引导给折腾坏了，记录一下修复方法</p>
<!-- more -->
<h2 id="系统引导修复">系统引导修复</h2>
<ol>
<li>进入PE系统</li>
<li>新建一个分区，系统模式为ESP</li>
<li>记住ESP分区对应的盘符，未分配盘符的话可 用工具进行挂载</li>
<li>系统命令模式下，输入下列命令<pre><code class="language-shell">    bcdboot c:\windows /s z: /f UEFI /l zh-cn
</code></pre>
</li>
<li>查看引导文件是否建立成功</li>
</ol>
]]></content>
    </entry>
</feed>